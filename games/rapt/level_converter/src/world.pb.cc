// Generated by the protocol buffer compiler.  DO NOT EDIT!

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "world.pb.h"
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace {

const ::google::protobuf::Descriptor* FileEnemy_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  FileEnemy_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* FileEnemy_EnemyType_descriptor_ = NULL;
const ::google::protobuf::Descriptor* FileButton_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  FileButton_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* FileButton_ButtonBehavior_descriptor_ = NULL;
const ::google::protobuf::Descriptor* FileDoor_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  FileDoor_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* FileDoor_DoorState_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* FileDoor_DoorType_descriptor_ = NULL;
const ::google::protobuf::Descriptor* FileCell_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  FileCell_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* FileCell_CellType_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* FileCell_EdgeType_descriptor_ = NULL;
const ::google::protobuf::Descriptor* FileSector_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  FileSector_reflection_ = NULL;
const ::google::protobuf::Descriptor* FileCog_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  FileCog_reflection_ = NULL;
const ::google::protobuf::Descriptor* FileSign_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  FileSign_reflection_ = NULL;
const ::google::protobuf::Descriptor* FileWorld_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  FileWorld_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* FileColor_descriptor_ = NULL;

}  // namespace


void protobuf_AssignDesc_world_2eproto() {
  protobuf_AddDesc_world_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "world.proto");
  GOOGLE_CHECK(file != NULL);
  FileEnemy_descriptor_ = file->message_type(0);
  static const int FileEnemy_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FileEnemy, center_x_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FileEnemy, center_y_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FileEnemy, angle_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FileEnemy, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FileEnemy, color_),
  };
  FileEnemy_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      FileEnemy_descriptor_,
      FileEnemy::default_instance_,
      FileEnemy_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FileEnemy, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FileEnemy, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(FileEnemy));
  FileEnemy_EnemyType_descriptor_ = FileEnemy_descriptor_->enum_type(0);
  FileButton_descriptor_ = file->message_type(1);
  static const int FileButton_offsets_[6] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FileButton, position_x_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FileButton, position_y_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FileButton, is_visible_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FileButton, behavior_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FileButton, color_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FileButton, door_index_),
  };
  FileButton_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      FileButton_descriptor_,
      FileButton::default_instance_,
      FileButton_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FileButton, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FileButton, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(FileButton));
  FileButton_ButtonBehavior_descriptor_ = FileButton_descriptor_->enum_type(0);
  FileDoor_descriptor_ = file->message_type(2);
  static const int FileDoor_offsets_[7] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FileDoor, start_x_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FileDoor, start_y_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FileDoor, end_x_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FileDoor, end_y_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FileDoor, state_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FileDoor, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FileDoor, color_),
  };
  FileDoor_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      FileDoor_descriptor_,
      FileDoor::default_instance_,
      FileDoor_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FileDoor, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FileDoor, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(FileDoor));
  FileDoor_DoorState_descriptor_ = FileDoor_descriptor_->enum_type(0);
  FileDoor_DoorType_descriptor_ = FileDoor_descriptor_->enum_type(1);
  FileCell_descriptor_ = file->message_type(3);
  static const int FileCell_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FileCell, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FileCell, edge_),
  };
  FileCell_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      FileCell_descriptor_,
      FileCell::default_instance_,
      FileCell_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FileCell, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FileCell, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(FileCell));
  FileCell_CellType_descriptor_ = FileCell_descriptor_->enum_type(0);
  FileCell_EdgeType_descriptor_ = FileCell_descriptor_->enum_type(1);
  FileSector_descriptor_ = file->message_type(4);
  static const int FileSector_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FileSector, cell_),
  };
  FileSector_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      FileSector_descriptor_,
      FileSector::default_instance_,
      FileSector_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FileSector, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FileSector, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(FileSector));
  FileCog_descriptor_ = file->message_type(5);
  static const int FileCog_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FileCog, cog_x_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FileCog, cog_y_),
  };
  FileCog_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      FileCog_descriptor_,
      FileCog::default_instance_,
      FileCog_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FileCog, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FileCog, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(FileCog));
  FileSign_descriptor_ = file->message_type(6);
  static const int FileSign_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FileSign, sign_x_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FileSign, sign_y_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FileSign, text_),
  };
  FileSign_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      FileSign_descriptor_,
      FileSign::default_instance_,
      FileSign_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FileSign, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FileSign, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(FileSign));
  FileWorld_descriptor_ = file->message_type(7);
  static const int FileWorld_offsets_[13] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FileWorld, players_start_x_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FileWorld, players_start_y_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FileWorld, players_end_x_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FileWorld, players_end_y_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FileWorld, width_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FileWorld, height_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FileWorld, sector_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FileWorld, button_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FileWorld, enemy_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FileWorld, door_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FileWorld, cog_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FileWorld, unique_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FileWorld, sign_),
  };
  FileWorld_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      FileWorld_descriptor_,
      FileWorld::default_instance_,
      FileWorld_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FileWorld, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FileWorld, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(FileWorld));
  FileColor_descriptor_ = file->enum_type(0);
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_world_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    FileEnemy_descriptor_, &FileEnemy::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    FileButton_descriptor_, &FileButton::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    FileDoor_descriptor_, &FileDoor::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    FileCell_descriptor_, &FileCell::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    FileSector_descriptor_, &FileSector::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    FileCog_descriptor_, &FileCog::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    FileSign_descriptor_, &FileSign::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    FileWorld_descriptor_, &FileWorld::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_world_2eproto() {
  delete FileEnemy::default_instance_;
  delete FileEnemy_reflection_;
  delete FileButton::default_instance_;
  delete FileButton_reflection_;
  delete FileDoor::default_instance_;
  delete FileDoor_reflection_;
  delete FileCell::default_instance_;
  delete FileCell_reflection_;
  delete FileSector::default_instance_;
  delete FileSector_reflection_;
  delete FileCog::default_instance_;
  delete FileCog_reflection_;
  delete FileSign::default_instance_;
  delete FileSign_reflection_;
  delete FileWorld::default_instance_;
  delete FileWorld_reflection_;
}

void protobuf_AddDesc_world_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\013world.proto\"\212\004\n\tFileEnemy\022\020\n\010center_x\030"
    "\001 \002(\002\022\020\n\010center_y\030\002 \002(\002\022\r\n\005angle\030\003 \002(\002\022\""
    "\n\004type\030\004 \002(\0162\024.FileEnemy.EnemyType\022\031\n\005co"
    "lor\030\005 \002(\0162\n.FileColor\"\212\003\n\tEnemyType\022\020\n\014E"
    "NEMY_BOMBER\020\000\022\025\n\021ENEMY_DOOM_MAGNET\020\001\022\023\n\017"
    "ENEMY_GRENADIER\020\002\022\022\n\016ENEMY_HEADACHE\020\003\022\020\n"
    "\014ENEMY_POPPER\020\004\022\022\n\016ENEMY_RIOT_GUN\020\005\022\024\n\020E"
    "NEMY_SHOCK_HAWK\020\006\022\023\n\017ENEMY_STALACBAT\020\007\022\026"
    "\n\022ENEMY_WALL_CRAWLER\020\010\022\025\n\021ENEMY_WHEELIGA"
    "TOR\020\t\022\027\n\023ENEMY_ROCKET_SPIDER\020\n\022\020\n\014ENEMY_"
    "HUNTER\020\013\022\026\n\022ENEMY_WALL_AVOIDER\020\014\022\024\n\020ENEM"
    "Y_SPIKE_BALL\020\r\022\031\n\025ENEMY_CORROSION_CLOUD\020"
    "\016\022 \n\034ENEMY_BOUNCY_ROCKET_LAUNCHER\020\017\022\025\n\021E"
    "NEMY_MULTI_THROW\020\020\"\344\001\n\nFileButton\022\022\n\npos"
    "ition_x\030\001 \002(\002\022\022\n\nposition_y\030\002 \002(\002\022\022\n\nis_"
    "visible\030\003 \002(\010\022,\n\010behavior\030\004 \002(\0162\032.FileBu"
    "tton.ButtonBehavior\022\031\n\005color\030\005 \002(\0162\n.Fil"
    "eColor\022\022\n\ndoor_index\030\006 \003(\005\"=\n\016ButtonBeha"
    "vior\022\014\n\010OPEN_ALL\020\000\022\r\n\tCLOSE_ALL\020\001\022\016\n\nTOG"
    "GLE_ALL\020\002\"\376\001\n\010FileDoor\022\017\n\007start_x\030\001 \002(\005\022"
    "\017\n\007start_y\030\002 \002(\005\022\r\n\005end_x\030\003 \002(\005\022\r\n\005end_y"
    "\030\004 \002(\005\022\"\n\005state\030\005 \002(\0162\023.FileDoor.DoorSta"
    "te\022 \n\004type\030\006 \002(\0162\022.FileDoor.DoorType\022\031\n\005"
    "color\030\007 \002(\0162\n.FileColor\"+\n\tDoorState\022\r\n\t"
    "DOOR_OPEN\020\000\022\017\n\013DOOR_CLOSED\020\001\"$\n\010DoorType"
    "\022\013\n\007ONE_WAY\020\000\022\013\n\007TWO_WAY\020\001\"\264\002\n\010FileCell\022"
    " \n\004type\030\001 \002(\0162\022.FileCell.CellType\022 \n\004edg"
    "e\030\002 \003(\0162\022.FileCell.EdgeType\"\222\001\n\010CellType"
    "\022\016\n\nCELL_EMPTY\020\000\022\016\n\nCELL_SOLID\020\001\022\030\n\024CELL"
    "_FLOOR_DIAG_LEFT\020\002\022\031\n\025CELL_FLOOR_DIAG_RI"
    "GHT\020\003\022\027\n\023CELL_CEIL_DIAG_LEFT\020\004\022\030\n\024CELL_C"
    "EIL_DIAG_RIGHT\020\005\"O\n\010EdgeType\022\016\n\nEDGE_EMP"
    "TY\020\000\022\017\n\013EDGE_NORMAL\020\001\022\017\n\013EDGE_STICKY\020\002\022\021"
    "\n\rEDGE_SLIPPERY\020\003\"%\n\nFileSector\022\027\n\004cell\030"
    "\001 \003(\0132\t.FileCell\"\'\n\007FileCog\022\r\n\005cog_x\030\001 \002"
    "(\002\022\r\n\005cog_y\030\002 \002(\002\"8\n\010FileSign\022\016\n\006sign_x\030"
    "\001 \002(\002\022\016\n\006sign_y\030\002 \002(\002\022\014\n\004text\030\003 \002(\t\"\273\002\n\t"
    "FileWorld\022\027\n\017players_start_x\030\001 \002(\005\022\027\n\017pl"
    "ayers_start_y\030\002 \002(\005\022\025\n\rplayers_end_x\030\003 \002"
    "(\005\022\025\n\rplayers_end_y\030\004 \002(\005\022\r\n\005width\030\005 \002(\005"
    "\022\016\n\006height\030\006 \002(\005\022\033\n\006sector\030\007 \003(\0132\013.FileS"
    "ector\022\033\n\006button\030\010 \003(\0132\013.FileButton\022\031\n\005en"
    "emy\030\t \003(\0132\n.FileEnemy\022\027\n\004door\030\n \003(\0132\t.Fi"
    "leDoor\022\025\n\003cog\030\013 \003(\0132\010.FileCog\022\021\n\tunique_"
    "id\030\014 \001(\005\022\027\n\004sign\030\r \003(\0132\t.FileSign*+\n\tFil"
    "eColor\022\013\n\007NEUTRAL\020\000\022\007\n\003RED\020\001\022\010\n\004BLUE\020\002", 1838);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "world.proto", &protobuf_RegisterTypes);
  FileEnemy::default_instance_ = new FileEnemy();
  FileButton::default_instance_ = new FileButton();
  FileDoor::default_instance_ = new FileDoor();
  FileCell::default_instance_ = new FileCell();
  FileSector::default_instance_ = new FileSector();
  FileCog::default_instance_ = new FileCog();
  FileSign::default_instance_ = new FileSign();
  FileWorld::default_instance_ = new FileWorld();
  FileEnemy::default_instance_->InitAsDefaultInstance();
  FileButton::default_instance_->InitAsDefaultInstance();
  FileDoor::default_instance_->InitAsDefaultInstance();
  FileCell::default_instance_->InitAsDefaultInstance();
  FileSector::default_instance_->InitAsDefaultInstance();
  FileCog::default_instance_->InitAsDefaultInstance();
  FileSign::default_instance_->InitAsDefaultInstance();
  FileWorld::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_world_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_world_2eproto {
  StaticDescriptorInitializer_world_2eproto() {
    protobuf_AddDesc_world_2eproto();
  }
} static_descriptor_initializer_world_2eproto_;

const ::google::protobuf::EnumDescriptor* FileColor_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return FileColor_descriptor_;
}
bool FileColor_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* FileEnemy_EnemyType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return FileEnemy_EnemyType_descriptor_;
}
bool FileEnemy_EnemyType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const FileEnemy_EnemyType FileEnemy::ENEMY_BOMBER;
const FileEnemy_EnemyType FileEnemy::ENEMY_DOOM_MAGNET;
const FileEnemy_EnemyType FileEnemy::ENEMY_GRENADIER;
const FileEnemy_EnemyType FileEnemy::ENEMY_HEADACHE;
const FileEnemy_EnemyType FileEnemy::ENEMY_POPPER;
const FileEnemy_EnemyType FileEnemy::ENEMY_RIOT_GUN;
const FileEnemy_EnemyType FileEnemy::ENEMY_SHOCK_HAWK;
const FileEnemy_EnemyType FileEnemy::ENEMY_STALACBAT;
const FileEnemy_EnemyType FileEnemy::ENEMY_WALL_CRAWLER;
const FileEnemy_EnemyType FileEnemy::ENEMY_WHEELIGATOR;
const FileEnemy_EnemyType FileEnemy::ENEMY_ROCKET_SPIDER;
const FileEnemy_EnemyType FileEnemy::ENEMY_HUNTER;
const FileEnemy_EnemyType FileEnemy::ENEMY_WALL_AVOIDER;
const FileEnemy_EnemyType FileEnemy::ENEMY_SPIKE_BALL;
const FileEnemy_EnemyType FileEnemy::ENEMY_CORROSION_CLOUD;
const FileEnemy_EnemyType FileEnemy::ENEMY_BOUNCY_ROCKET_LAUNCHER;
const FileEnemy_EnemyType FileEnemy::ENEMY_MULTI_THROW;
const FileEnemy_EnemyType FileEnemy::EnemyType_MIN;
const FileEnemy_EnemyType FileEnemy::EnemyType_MAX;
const int FileEnemy::EnemyType_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int FileEnemy::kCenterXFieldNumber;
const int FileEnemy::kCenterYFieldNumber;
const int FileEnemy::kAngleFieldNumber;
const int FileEnemy::kTypeFieldNumber;
const int FileEnemy::kColorFieldNumber;
#endif  // !_MSC_VER

FileEnemy::FileEnemy()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void FileEnemy::InitAsDefaultInstance() {
}

FileEnemy::FileEnemy(const FileEnemy& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void FileEnemy::SharedCtor() {
  _cached_size_ = 0;
  center_x_ = 0;
  center_y_ = 0;
  angle_ = 0;
  type_ = 0;
  color_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

FileEnemy::~FileEnemy() {
  SharedDtor();
}

void FileEnemy::SharedDtor() {
  if (this != default_instance_) {
  }
}

void FileEnemy::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* FileEnemy::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return FileEnemy_descriptor_;
}

const FileEnemy& FileEnemy::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_world_2eproto();  return *default_instance_;
}

FileEnemy* FileEnemy::default_instance_ = NULL;

FileEnemy* FileEnemy::New() const {
  return new FileEnemy;
}

void FileEnemy::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    center_x_ = 0;
    center_y_ = 0;
    angle_ = 0;
    type_ = 0;
    color_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool FileEnemy::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required float center_x = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &center_x_)));
          _set_bit(0);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(21)) goto parse_center_y;
        break;
      }
      
      // required float center_y = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_center_y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &center_y_)));
          _set_bit(1);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(29)) goto parse_angle;
        break;
      }
      
      // required float angle = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_angle:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &angle_)));
          _set_bit(2);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_type;
        break;
      }
      
      // required .FileEnemy.EnemyType type = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::FileEnemy_EnemyType_IsValid(value)) {
            set_type(static_cast< ::FileEnemy_EnemyType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(4, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_color;
        break;
      }
      
      // required .FileColor color = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_color:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (FileColor_IsValid(value)) {
            set_color(static_cast< FileColor >(value));
          } else {
            mutable_unknown_fields()->AddVarint(5, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void FileEnemy::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required float center_x = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->center_x(), output);
  }
  
  // required float center_y = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->center_y(), output);
  }
  
  // required float angle = 3;
  if (_has_bit(2)) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->angle(), output);
  }
  
  // required .FileEnemy.EnemyType type = 4;
  if (_has_bit(3)) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      4, this->type(), output);
  }
  
  // required .FileColor color = 5;
  if (_has_bit(4)) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      5, this->color(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* FileEnemy::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required float center_x = 1;
  if (_has_bit(0)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(1, this->center_x(), target);
  }
  
  // required float center_y = 2;
  if (_has_bit(1)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->center_y(), target);
  }
  
  // required float angle = 3;
  if (_has_bit(2)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(3, this->angle(), target);
  }
  
  // required .FileEnemy.EnemyType type = 4;
  if (_has_bit(3)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      4, this->type(), target);
  }
  
  // required .FileColor color = 5;
  if (_has_bit(4)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      5, this->color(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int FileEnemy::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required float center_x = 1;
    if (has_center_x()) {
      total_size += 1 + 4;
    }
    
    // required float center_y = 2;
    if (has_center_y()) {
      total_size += 1 + 4;
    }
    
    // required float angle = 3;
    if (has_angle()) {
      total_size += 1 + 4;
    }
    
    // required .FileEnemy.EnemyType type = 4;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }
    
    // required .FileColor color = 5;
    if (has_color()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->color());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FileEnemy::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const FileEnemy* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const FileEnemy*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void FileEnemy::MergeFrom(const FileEnemy& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_center_x(from.center_x());
    }
    if (from._has_bit(1)) {
      set_center_y(from.center_y());
    }
    if (from._has_bit(2)) {
      set_angle(from.angle());
    }
    if (from._has_bit(3)) {
      set_type(from.type());
    }
    if (from._has_bit(4)) {
      set_color(from.color());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void FileEnemy::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void FileEnemy::CopyFrom(const FileEnemy& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FileEnemy::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000001f) != 0x0000001f) return false;
  
  return true;
}

void FileEnemy::Swap(FileEnemy* other) {
  if (other != this) {
    std::swap(center_x_, other->center_x_);
    std::swap(center_y_, other->center_y_);
    std::swap(angle_, other->angle_);
    std::swap(type_, other->type_);
    std::swap(color_, other->color_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata FileEnemy::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = FileEnemy_descriptor_;
  metadata.reflection = FileEnemy_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* FileButton_ButtonBehavior_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return FileButton_ButtonBehavior_descriptor_;
}
bool FileButton_ButtonBehavior_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const FileButton_ButtonBehavior FileButton::OPEN_ALL;
const FileButton_ButtonBehavior FileButton::CLOSE_ALL;
const FileButton_ButtonBehavior FileButton::TOGGLE_ALL;
const FileButton_ButtonBehavior FileButton::ButtonBehavior_MIN;
const FileButton_ButtonBehavior FileButton::ButtonBehavior_MAX;
const int FileButton::ButtonBehavior_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int FileButton::kPositionXFieldNumber;
const int FileButton::kPositionYFieldNumber;
const int FileButton::kIsVisibleFieldNumber;
const int FileButton::kBehaviorFieldNumber;
const int FileButton::kColorFieldNumber;
const int FileButton::kDoorIndexFieldNumber;
#endif  // !_MSC_VER

FileButton::FileButton()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void FileButton::InitAsDefaultInstance() {
}

FileButton::FileButton(const FileButton& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void FileButton::SharedCtor() {
  _cached_size_ = 0;
  position_x_ = 0;
  position_y_ = 0;
  is_visible_ = false;
  behavior_ = 0;
  color_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

FileButton::~FileButton() {
  SharedDtor();
}

void FileButton::SharedDtor() {
  if (this != default_instance_) {
  }
}

void FileButton::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* FileButton::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return FileButton_descriptor_;
}

const FileButton& FileButton::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_world_2eproto();  return *default_instance_;
}

FileButton* FileButton::default_instance_ = NULL;

FileButton* FileButton::New() const {
  return new FileButton;
}

void FileButton::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    position_x_ = 0;
    position_y_ = 0;
    is_visible_ = false;
    behavior_ = 0;
    color_ = 0;
  }
  door_index_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool FileButton::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required float position_x = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &position_x_)));
          _set_bit(0);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(21)) goto parse_position_y;
        break;
      }
      
      // required float position_y = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_position_y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &position_y_)));
          _set_bit(1);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_is_visible;
        break;
      }
      
      // required bool is_visible = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_is_visible:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &is_visible_)));
          _set_bit(2);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_behavior;
        break;
      }
      
      // required .FileButton.ButtonBehavior behavior = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_behavior:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::FileButton_ButtonBehavior_IsValid(value)) {
            set_behavior(static_cast< ::FileButton_ButtonBehavior >(value));
          } else {
            mutable_unknown_fields()->AddVarint(4, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_color;
        break;
      }
      
      // required .FileColor color = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_color:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (FileColor_IsValid(value)) {
            set_color(static_cast< FileColor >(value));
          } else {
            mutable_unknown_fields()->AddVarint(5, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_door_index;
        break;
      }
      
      // repeated int32 door_index = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_door_index:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 1, 48, input, this->mutable_door_index())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, this->mutable_door_index())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_door_index;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void FileButton::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required float position_x = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->position_x(), output);
  }
  
  // required float position_y = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->position_y(), output);
  }
  
  // required bool is_visible = 3;
  if (_has_bit(2)) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(3, this->is_visible(), output);
  }
  
  // required .FileButton.ButtonBehavior behavior = 4;
  if (_has_bit(3)) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      4, this->behavior(), output);
  }
  
  // required .FileColor color = 5;
  if (_has_bit(4)) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      5, this->color(), output);
  }
  
  // repeated int32 door_index = 6;
  for (int i = 0; i < this->door_index_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(
      6, this->door_index(i), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* FileButton::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required float position_x = 1;
  if (_has_bit(0)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(1, this->position_x(), target);
  }
  
  // required float position_y = 2;
  if (_has_bit(1)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->position_y(), target);
  }
  
  // required bool is_visible = 3;
  if (_has_bit(2)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(3, this->is_visible(), target);
  }
  
  // required .FileButton.ButtonBehavior behavior = 4;
  if (_has_bit(3)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      4, this->behavior(), target);
  }
  
  // required .FileColor color = 5;
  if (_has_bit(4)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      5, this->color(), target);
  }
  
  // repeated int32 door_index = 6;
  for (int i = 0; i < this->door_index_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteInt32ToArray(6, this->door_index(i), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int FileButton::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required float position_x = 1;
    if (has_position_x()) {
      total_size += 1 + 4;
    }
    
    // required float position_y = 2;
    if (has_position_y()) {
      total_size += 1 + 4;
    }
    
    // required bool is_visible = 3;
    if (has_is_visible()) {
      total_size += 1 + 1;
    }
    
    // required .FileButton.ButtonBehavior behavior = 4;
    if (has_behavior()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->behavior());
    }
    
    // required .FileColor color = 5;
    if (has_color()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->color());
    }
    
  }
  // repeated int32 door_index = 6;
  {
    int data_size = 0;
    for (int i = 0; i < this->door_index_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        Int32Size(this->door_index(i));
    }
    total_size += 1 * this->door_index_size() + data_size;
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FileButton::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const FileButton* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const FileButton*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void FileButton::MergeFrom(const FileButton& from) {
  GOOGLE_CHECK_NE(&from, this);
  door_index_.MergeFrom(from.door_index_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_position_x(from.position_x());
    }
    if (from._has_bit(1)) {
      set_position_y(from.position_y());
    }
    if (from._has_bit(2)) {
      set_is_visible(from.is_visible());
    }
    if (from._has_bit(3)) {
      set_behavior(from.behavior());
    }
    if (from._has_bit(4)) {
      set_color(from.color());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void FileButton::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void FileButton::CopyFrom(const FileButton& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FileButton::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000001f) != 0x0000001f) return false;
  
  return true;
}

void FileButton::Swap(FileButton* other) {
  if (other != this) {
    std::swap(position_x_, other->position_x_);
    std::swap(position_y_, other->position_y_);
    std::swap(is_visible_, other->is_visible_);
    std::swap(behavior_, other->behavior_);
    std::swap(color_, other->color_);
    door_index_.Swap(&other->door_index_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata FileButton::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = FileButton_descriptor_;
  metadata.reflection = FileButton_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* FileDoor_DoorState_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return FileDoor_DoorState_descriptor_;
}
bool FileDoor_DoorState_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const FileDoor_DoorState FileDoor::DOOR_OPEN;
const FileDoor_DoorState FileDoor::DOOR_CLOSED;
const FileDoor_DoorState FileDoor::DoorState_MIN;
const FileDoor_DoorState FileDoor::DoorState_MAX;
const int FileDoor::DoorState_ARRAYSIZE;
#endif  // _MSC_VER
const ::google::protobuf::EnumDescriptor* FileDoor_DoorType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return FileDoor_DoorType_descriptor_;
}
bool FileDoor_DoorType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const FileDoor_DoorType FileDoor::ONE_WAY;
const FileDoor_DoorType FileDoor::TWO_WAY;
const FileDoor_DoorType FileDoor::DoorType_MIN;
const FileDoor_DoorType FileDoor::DoorType_MAX;
const int FileDoor::DoorType_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int FileDoor::kStartXFieldNumber;
const int FileDoor::kStartYFieldNumber;
const int FileDoor::kEndXFieldNumber;
const int FileDoor::kEndYFieldNumber;
const int FileDoor::kStateFieldNumber;
const int FileDoor::kTypeFieldNumber;
const int FileDoor::kColorFieldNumber;
#endif  // !_MSC_VER

FileDoor::FileDoor()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void FileDoor::InitAsDefaultInstance() {
}

FileDoor::FileDoor(const FileDoor& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void FileDoor::SharedCtor() {
  _cached_size_ = 0;
  start_x_ = 0;
  start_y_ = 0;
  end_x_ = 0;
  end_y_ = 0;
  state_ = 0;
  type_ = 0;
  color_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

FileDoor::~FileDoor() {
  SharedDtor();
}

void FileDoor::SharedDtor() {
  if (this != default_instance_) {
  }
}

void FileDoor::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* FileDoor::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return FileDoor_descriptor_;
}

const FileDoor& FileDoor::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_world_2eproto();  return *default_instance_;
}

FileDoor* FileDoor::default_instance_ = NULL;

FileDoor* FileDoor::New() const {
  return new FileDoor;
}

void FileDoor::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    start_x_ = 0;
    start_y_ = 0;
    end_x_ = 0;
    end_y_ = 0;
    state_ = 0;
    type_ = 0;
    color_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool FileDoor::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 start_x = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &start_x_)));
          _set_bit(0);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_start_y;
        break;
      }
      
      // required int32 start_y = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_start_y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &start_y_)));
          _set_bit(1);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_end_x;
        break;
      }
      
      // required int32 end_x = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_end_x:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &end_x_)));
          _set_bit(2);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_end_y;
        break;
      }
      
      // required int32 end_y = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_end_y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &end_y_)));
          _set_bit(3);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_state;
        break;
      }
      
      // required .FileDoor.DoorState state = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_state:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::FileDoor_DoorState_IsValid(value)) {
            set_state(static_cast< ::FileDoor_DoorState >(value));
          } else {
            mutable_unknown_fields()->AddVarint(5, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_type;
        break;
      }
      
      // required .FileDoor.DoorType type = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::FileDoor_DoorType_IsValid(value)) {
            set_type(static_cast< ::FileDoor_DoorType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(6, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_color;
        break;
      }
      
      // required .FileColor color = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_color:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (FileColor_IsValid(value)) {
            set_color(static_cast< FileColor >(value));
          } else {
            mutable_unknown_fields()->AddVarint(7, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void FileDoor::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 start_x = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->start_x(), output);
  }
  
  // required int32 start_y = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->start_y(), output);
  }
  
  // required int32 end_x = 3;
  if (_has_bit(2)) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->end_x(), output);
  }
  
  // required int32 end_y = 4;
  if (_has_bit(3)) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->end_y(), output);
  }
  
  // required .FileDoor.DoorState state = 5;
  if (_has_bit(4)) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      5, this->state(), output);
  }
  
  // required .FileDoor.DoorType type = 6;
  if (_has_bit(5)) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      6, this->type(), output);
  }
  
  // required .FileColor color = 7;
  if (_has_bit(6)) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      7, this->color(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* FileDoor::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 start_x = 1;
  if (_has_bit(0)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->start_x(), target);
  }
  
  // required int32 start_y = 2;
  if (_has_bit(1)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->start_y(), target);
  }
  
  // required int32 end_x = 3;
  if (_has_bit(2)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->end_x(), target);
  }
  
  // required int32 end_y = 4;
  if (_has_bit(3)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->end_y(), target);
  }
  
  // required .FileDoor.DoorState state = 5;
  if (_has_bit(4)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      5, this->state(), target);
  }
  
  // required .FileDoor.DoorType type = 6;
  if (_has_bit(5)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      6, this->type(), target);
  }
  
  // required .FileColor color = 7;
  if (_has_bit(6)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      7, this->color(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int FileDoor::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 start_x = 1;
    if (has_start_x()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->start_x());
    }
    
    // required int32 start_y = 2;
    if (has_start_y()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->start_y());
    }
    
    // required int32 end_x = 3;
    if (has_end_x()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->end_x());
    }
    
    // required int32 end_y = 4;
    if (has_end_y()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->end_y());
    }
    
    // required .FileDoor.DoorState state = 5;
    if (has_state()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->state());
    }
    
    // required .FileDoor.DoorType type = 6;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }
    
    // required .FileColor color = 7;
    if (has_color()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->color());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FileDoor::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const FileDoor* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const FileDoor*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void FileDoor::MergeFrom(const FileDoor& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_start_x(from.start_x());
    }
    if (from._has_bit(1)) {
      set_start_y(from.start_y());
    }
    if (from._has_bit(2)) {
      set_end_x(from.end_x());
    }
    if (from._has_bit(3)) {
      set_end_y(from.end_y());
    }
    if (from._has_bit(4)) {
      set_state(from.state());
    }
    if (from._has_bit(5)) {
      set_type(from.type());
    }
    if (from._has_bit(6)) {
      set_color(from.color());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void FileDoor::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void FileDoor::CopyFrom(const FileDoor& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FileDoor::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000007f) != 0x0000007f) return false;
  
  return true;
}

void FileDoor::Swap(FileDoor* other) {
  if (other != this) {
    std::swap(start_x_, other->start_x_);
    std::swap(start_y_, other->start_y_);
    std::swap(end_x_, other->end_x_);
    std::swap(end_y_, other->end_y_);
    std::swap(state_, other->state_);
    std::swap(type_, other->type_);
    std::swap(color_, other->color_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata FileDoor::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = FileDoor_descriptor_;
  metadata.reflection = FileDoor_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* FileCell_CellType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return FileCell_CellType_descriptor_;
}
bool FileCell_CellType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const FileCell_CellType FileCell::CELL_EMPTY;
const FileCell_CellType FileCell::CELL_SOLID;
const FileCell_CellType FileCell::CELL_FLOOR_DIAG_LEFT;
const FileCell_CellType FileCell::CELL_FLOOR_DIAG_RIGHT;
const FileCell_CellType FileCell::CELL_CEIL_DIAG_LEFT;
const FileCell_CellType FileCell::CELL_CEIL_DIAG_RIGHT;
const FileCell_CellType FileCell::CellType_MIN;
const FileCell_CellType FileCell::CellType_MAX;
const int FileCell::CellType_ARRAYSIZE;
#endif  // _MSC_VER
const ::google::protobuf::EnumDescriptor* FileCell_EdgeType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return FileCell_EdgeType_descriptor_;
}
bool FileCell_EdgeType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const FileCell_EdgeType FileCell::EDGE_EMPTY;
const FileCell_EdgeType FileCell::EDGE_NORMAL;
const FileCell_EdgeType FileCell::EDGE_STICKY;
const FileCell_EdgeType FileCell::EDGE_SLIPPERY;
const FileCell_EdgeType FileCell::EdgeType_MIN;
const FileCell_EdgeType FileCell::EdgeType_MAX;
const int FileCell::EdgeType_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int FileCell::kTypeFieldNumber;
const int FileCell::kEdgeFieldNumber;
#endif  // !_MSC_VER

FileCell::FileCell()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void FileCell::InitAsDefaultInstance() {
}

FileCell::FileCell(const FileCell& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void FileCell::SharedCtor() {
  _cached_size_ = 0;
  type_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

FileCell::~FileCell() {
  SharedDtor();
}

void FileCell::SharedDtor() {
  if (this != default_instance_) {
  }
}

void FileCell::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* FileCell::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return FileCell_descriptor_;
}

const FileCell& FileCell::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_world_2eproto();  return *default_instance_;
}

FileCell* FileCell::default_instance_ = NULL;

FileCell* FileCell::New() const {
  return new FileCell;
}

void FileCell::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    type_ = 0;
  }
  edge_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool FileCell::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .FileCell.CellType type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::FileCell_CellType_IsValid(value)) {
            set_type(static_cast< ::FileCell_CellType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_edge;
        break;
      }
      
      // repeated .FileCell.EdgeType edge = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_edge:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::FileCell_EdgeType_IsValid(value)) {
            add_edge(static_cast< ::FileCell_EdgeType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(2, value);
          }
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedEnumNoInline(
                 input,
                 &::FileCell_EdgeType_IsValid,
                 this->mutable_edge())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_edge;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void FileCell::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .FileCell.CellType type = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }
  
  // repeated .FileCell.EdgeType edge = 2;
  for (int i = 0; i < this->edge_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->edge(i), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* FileCell::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .FileCell.CellType type = 1;
  if (_has_bit(0)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->type(), target);
  }
  
  // repeated .FileCell.EdgeType edge = 2;
  for (int i = 0; i < this->edge_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->edge(i), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int FileCell::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .FileCell.CellType type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }
    
  }
  // repeated .FileCell.EdgeType edge = 2;
  {
    int data_size = 0;
    for (int i = 0; i < this->edge_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::EnumSize(
        this->edge(i));
    }
    total_size += 1 * this->edge_size() + data_size;
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FileCell::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const FileCell* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const FileCell*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void FileCell::MergeFrom(const FileCell& from) {
  GOOGLE_CHECK_NE(&from, this);
  edge_.MergeFrom(from.edge_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_type(from.type());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void FileCell::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void FileCell::CopyFrom(const FileCell& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FileCell::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  return true;
}

void FileCell::Swap(FileCell* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    edge_.Swap(&other->edge_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata FileCell::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = FileCell_descriptor_;
  metadata.reflection = FileCell_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int FileSector::kCellFieldNumber;
#endif  // !_MSC_VER

FileSector::FileSector()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void FileSector::InitAsDefaultInstance() {
}

FileSector::FileSector(const FileSector& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void FileSector::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

FileSector::~FileSector() {
  SharedDtor();
}

void FileSector::SharedDtor() {
  if (this != default_instance_) {
  }
}

void FileSector::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* FileSector::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return FileSector_descriptor_;
}

const FileSector& FileSector::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_world_2eproto();  return *default_instance_;
}

FileSector* FileSector::default_instance_ = NULL;

FileSector* FileSector::New() const {
  return new FileSector;
}

void FileSector::Clear() {
  cell_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool FileSector::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .FileCell cell = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_cell:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_cell()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_cell;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void FileSector::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .FileCell cell = 1;
  for (int i = 0; i < this->cell_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->cell(i), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* FileSector::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .FileCell cell = 1;
  for (int i = 0; i < this->cell_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->cell(i), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int FileSector::ByteSize() const {
  int total_size = 0;
  
  // repeated .FileCell cell = 1;
  total_size += 1 * this->cell_size();
  for (int i = 0; i < this->cell_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->cell(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FileSector::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const FileSector* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const FileSector*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void FileSector::MergeFrom(const FileSector& from) {
  GOOGLE_CHECK_NE(&from, this);
  cell_.MergeFrom(from.cell_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void FileSector::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void FileSector::CopyFrom(const FileSector& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FileSector::IsInitialized() const {
  
  for (int i = 0; i < cell_size(); i++) {
    if (!this->cell(i).IsInitialized()) return false;
  }
  return true;
}

void FileSector::Swap(FileSector* other) {
  if (other != this) {
    cell_.Swap(&other->cell_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata FileSector::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = FileSector_descriptor_;
  metadata.reflection = FileSector_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int FileCog::kCogXFieldNumber;
const int FileCog::kCogYFieldNumber;
#endif  // !_MSC_VER

FileCog::FileCog()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void FileCog::InitAsDefaultInstance() {
}

FileCog::FileCog(const FileCog& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void FileCog::SharedCtor() {
  _cached_size_ = 0;
  cog_x_ = 0;
  cog_y_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

FileCog::~FileCog() {
  SharedDtor();
}

void FileCog::SharedDtor() {
  if (this != default_instance_) {
  }
}

void FileCog::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* FileCog::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return FileCog_descriptor_;
}

const FileCog& FileCog::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_world_2eproto();  return *default_instance_;
}

FileCog* FileCog::default_instance_ = NULL;

FileCog* FileCog::New() const {
  return new FileCog;
}

void FileCog::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    cog_x_ = 0;
    cog_y_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool FileCog::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required float cog_x = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &cog_x_)));
          _set_bit(0);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(21)) goto parse_cog_y;
        break;
      }
      
      // required float cog_y = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_cog_y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &cog_y_)));
          _set_bit(1);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void FileCog::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required float cog_x = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->cog_x(), output);
  }
  
  // required float cog_y = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->cog_y(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* FileCog::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required float cog_x = 1;
  if (_has_bit(0)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(1, this->cog_x(), target);
  }
  
  // required float cog_y = 2;
  if (_has_bit(1)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->cog_y(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int FileCog::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required float cog_x = 1;
    if (has_cog_x()) {
      total_size += 1 + 4;
    }
    
    // required float cog_y = 2;
    if (has_cog_y()) {
      total_size += 1 + 4;
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FileCog::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const FileCog* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const FileCog*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void FileCog::MergeFrom(const FileCog& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_cog_x(from.cog_x());
    }
    if (from._has_bit(1)) {
      set_cog_y(from.cog_y());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void FileCog::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void FileCog::CopyFrom(const FileCog& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FileCog::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  
  return true;
}

void FileCog::Swap(FileCog* other) {
  if (other != this) {
    std::swap(cog_x_, other->cog_x_);
    std::swap(cog_y_, other->cog_y_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata FileCog::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = FileCog_descriptor_;
  metadata.reflection = FileCog_reflection_;
  return metadata;
}


// ===================================================================

const ::std::string FileSign::_default_text_;
#ifndef _MSC_VER
const int FileSign::kSignXFieldNumber;
const int FileSign::kSignYFieldNumber;
const int FileSign::kTextFieldNumber;
#endif  // !_MSC_VER

FileSign::FileSign()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void FileSign::InitAsDefaultInstance() {
}

FileSign::FileSign(const FileSign& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void FileSign::SharedCtor() {
  _cached_size_ = 0;
  sign_x_ = 0;
  sign_y_ = 0;
  text_ = const_cast< ::std::string*>(&_default_text_);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

FileSign::~FileSign() {
  SharedDtor();
}

void FileSign::SharedDtor() {
  if (text_ != &_default_text_) {
    delete text_;
  }
  if (this != default_instance_) {
  }
}

void FileSign::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* FileSign::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return FileSign_descriptor_;
}

const FileSign& FileSign::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_world_2eproto();  return *default_instance_;
}

FileSign* FileSign::default_instance_ = NULL;

FileSign* FileSign::New() const {
  return new FileSign;
}

void FileSign::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    sign_x_ = 0;
    sign_y_ = 0;
    if (_has_bit(2)) {
      if (text_ != &_default_text_) {
        text_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool FileSign::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required float sign_x = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &sign_x_)));
          _set_bit(0);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(21)) goto parse_sign_y;
        break;
      }
      
      // required float sign_y = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_sign_y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &sign_y_)));
          _set_bit(1);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_text;
        break;
      }
      
      // required string text = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_text:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_text()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->text().data(), this->text().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void FileSign::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required float sign_x = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->sign_x(), output);
  }
  
  // required float sign_y = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->sign_y(), output);
  }
  
  // required string text = 3;
  if (_has_bit(2)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->text().data(), this->text().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->text(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* FileSign::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required float sign_x = 1;
  if (_has_bit(0)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(1, this->sign_x(), target);
  }
  
  // required float sign_y = 2;
  if (_has_bit(1)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->sign_y(), target);
  }
  
  // required string text = 3;
  if (_has_bit(2)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->text().data(), this->text().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->text(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int FileSign::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required float sign_x = 1;
    if (has_sign_x()) {
      total_size += 1 + 4;
    }
    
    // required float sign_y = 2;
    if (has_sign_y()) {
      total_size += 1 + 4;
    }
    
    // required string text = 3;
    if (has_text()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->text());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FileSign::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const FileSign* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const FileSign*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void FileSign::MergeFrom(const FileSign& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_sign_x(from.sign_x());
    }
    if (from._has_bit(1)) {
      set_sign_y(from.sign_y());
    }
    if (from._has_bit(2)) {
      set_text(from.text());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void FileSign::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void FileSign::CopyFrom(const FileSign& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FileSign::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;
  
  return true;
}

void FileSign::Swap(FileSign* other) {
  if (other != this) {
    std::swap(sign_x_, other->sign_x_);
    std::swap(sign_y_, other->sign_y_);
    std::swap(text_, other->text_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata FileSign::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = FileSign_descriptor_;
  metadata.reflection = FileSign_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int FileWorld::kPlayersStartXFieldNumber;
const int FileWorld::kPlayersStartYFieldNumber;
const int FileWorld::kPlayersEndXFieldNumber;
const int FileWorld::kPlayersEndYFieldNumber;
const int FileWorld::kWidthFieldNumber;
const int FileWorld::kHeightFieldNumber;
const int FileWorld::kSectorFieldNumber;
const int FileWorld::kButtonFieldNumber;
const int FileWorld::kEnemyFieldNumber;
const int FileWorld::kDoorFieldNumber;
const int FileWorld::kCogFieldNumber;
const int FileWorld::kUniqueIdFieldNumber;
const int FileWorld::kSignFieldNumber;
#endif  // !_MSC_VER

FileWorld::FileWorld()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void FileWorld::InitAsDefaultInstance() {
}

FileWorld::FileWorld(const FileWorld& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void FileWorld::SharedCtor() {
  _cached_size_ = 0;
  players_start_x_ = 0;
  players_start_y_ = 0;
  players_end_x_ = 0;
  players_end_y_ = 0;
  width_ = 0;
  height_ = 0;
  unique_id_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

FileWorld::~FileWorld() {
  SharedDtor();
}

void FileWorld::SharedDtor() {
  if (this != default_instance_) {
  }
}

void FileWorld::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* FileWorld::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return FileWorld_descriptor_;
}

const FileWorld& FileWorld::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_world_2eproto();  return *default_instance_;
}

FileWorld* FileWorld::default_instance_ = NULL;

FileWorld* FileWorld::New() const {
  return new FileWorld;
}

void FileWorld::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    players_start_x_ = 0;
    players_start_y_ = 0;
    players_end_x_ = 0;
    players_end_y_ = 0;
    width_ = 0;
    height_ = 0;
  }
  if (_has_bits_[11 / 32] & (0xffu << (11 % 32))) {
    unique_id_ = 0;
  }
  sector_.Clear();
  button_.Clear();
  enemy_.Clear();
  door_.Clear();
  cog_.Clear();
  sign_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool FileWorld::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 players_start_x = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &players_start_x_)));
          _set_bit(0);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_players_start_y;
        break;
      }
      
      // required int32 players_start_y = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_players_start_y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &players_start_y_)));
          _set_bit(1);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_players_end_x;
        break;
      }
      
      // required int32 players_end_x = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_players_end_x:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &players_end_x_)));
          _set_bit(2);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_players_end_y;
        break;
      }
      
      // required int32 players_end_y = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_players_end_y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &players_end_y_)));
          _set_bit(3);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_width;
        break;
      }
      
      // required int32 width = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_width:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &width_)));
          _set_bit(4);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_height;
        break;
      }
      
      // required int32 height = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_height:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &height_)));
          _set_bit(5);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(58)) goto parse_sector;
        break;
      }
      
      // repeated .FileSector sector = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_sector:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_sector()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(58)) goto parse_sector;
        if (input->ExpectTag(66)) goto parse_button;
        break;
      }
      
      // repeated .FileButton button = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_button:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_button()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(66)) goto parse_button;
        if (input->ExpectTag(74)) goto parse_enemy;
        break;
      }
      
      // repeated .FileEnemy enemy = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_enemy:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_enemy()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(74)) goto parse_enemy;
        if (input->ExpectTag(82)) goto parse_door;
        break;
      }
      
      // repeated .FileDoor door = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_door:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_door()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(82)) goto parse_door;
        if (input->ExpectTag(90)) goto parse_cog;
        break;
      }
      
      // repeated .FileCog cog = 11;
      case 11: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_cog:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_cog()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(90)) goto parse_cog;
        if (input->ExpectTag(96)) goto parse_unique_id;
        break;
      }
      
      // optional int32 unique_id = 12;
      case 12: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_unique_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &unique_id_)));
          _set_bit(11);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(106)) goto parse_sign;
        break;
      }
      
      // repeated .FileSign sign = 13;
      case 13: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_sign:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_sign()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(106)) goto parse_sign;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void FileWorld::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 players_start_x = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->players_start_x(), output);
  }
  
  // required int32 players_start_y = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->players_start_y(), output);
  }
  
  // required int32 players_end_x = 3;
  if (_has_bit(2)) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->players_end_x(), output);
  }
  
  // required int32 players_end_y = 4;
  if (_has_bit(3)) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->players_end_y(), output);
  }
  
  // required int32 width = 5;
  if (_has_bit(4)) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->width(), output);
  }
  
  // required int32 height = 6;
  if (_has_bit(5)) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(6, this->height(), output);
  }
  
  // repeated .FileSector sector = 7;
  for (int i = 0; i < this->sector_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, this->sector(i), output);
  }
  
  // repeated .FileButton button = 8;
  for (int i = 0; i < this->button_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      8, this->button(i), output);
  }
  
  // repeated .FileEnemy enemy = 9;
  for (int i = 0; i < this->enemy_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      9, this->enemy(i), output);
  }
  
  // repeated .FileDoor door = 10;
  for (int i = 0; i < this->door_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      10, this->door(i), output);
  }
  
  // repeated .FileCog cog = 11;
  for (int i = 0; i < this->cog_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      11, this->cog(i), output);
  }
  
  // optional int32 unique_id = 12;
  if (_has_bit(11)) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(12, this->unique_id(), output);
  }
  
  // repeated .FileSign sign = 13;
  for (int i = 0; i < this->sign_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      13, this->sign(i), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* FileWorld::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 players_start_x = 1;
  if (_has_bit(0)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->players_start_x(), target);
  }
  
  // required int32 players_start_y = 2;
  if (_has_bit(1)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->players_start_y(), target);
  }
  
  // required int32 players_end_x = 3;
  if (_has_bit(2)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->players_end_x(), target);
  }
  
  // required int32 players_end_y = 4;
  if (_has_bit(3)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->players_end_y(), target);
  }
  
  // required int32 width = 5;
  if (_has_bit(4)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(5, this->width(), target);
  }
  
  // required int32 height = 6;
  if (_has_bit(5)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(6, this->height(), target);
  }
  
  // repeated .FileSector sector = 7;
  for (int i = 0; i < this->sector_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        7, this->sector(i), target);
  }
  
  // repeated .FileButton button = 8;
  for (int i = 0; i < this->button_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        8, this->button(i), target);
  }
  
  // repeated .FileEnemy enemy = 9;
  for (int i = 0; i < this->enemy_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        9, this->enemy(i), target);
  }
  
  // repeated .FileDoor door = 10;
  for (int i = 0; i < this->door_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        10, this->door(i), target);
  }
  
  // repeated .FileCog cog = 11;
  for (int i = 0; i < this->cog_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        11, this->cog(i), target);
  }
  
  // optional int32 unique_id = 12;
  if (_has_bit(11)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(12, this->unique_id(), target);
  }
  
  // repeated .FileSign sign = 13;
  for (int i = 0; i < this->sign_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        13, this->sign(i), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int FileWorld::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 players_start_x = 1;
    if (has_players_start_x()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->players_start_x());
    }
    
    // required int32 players_start_y = 2;
    if (has_players_start_y()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->players_start_y());
    }
    
    // required int32 players_end_x = 3;
    if (has_players_end_x()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->players_end_x());
    }
    
    // required int32 players_end_y = 4;
    if (has_players_end_y()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->players_end_y());
    }
    
    // required int32 width = 5;
    if (has_width()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->width());
    }
    
    // required int32 height = 6;
    if (has_height()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->height());
    }
    
  }
  if (_has_bits_[11 / 32] & (0xffu << (11 % 32))) {
    // optional int32 unique_id = 12;
    if (has_unique_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->unique_id());
    }
    
  }
  // repeated .FileSector sector = 7;
  total_size += 1 * this->sector_size();
  for (int i = 0; i < this->sector_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->sector(i));
  }
  
  // repeated .FileButton button = 8;
  total_size += 1 * this->button_size();
  for (int i = 0; i < this->button_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->button(i));
  }
  
  // repeated .FileEnemy enemy = 9;
  total_size += 1 * this->enemy_size();
  for (int i = 0; i < this->enemy_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->enemy(i));
  }
  
  // repeated .FileDoor door = 10;
  total_size += 1 * this->door_size();
  for (int i = 0; i < this->door_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->door(i));
  }
  
  // repeated .FileCog cog = 11;
  total_size += 1 * this->cog_size();
  for (int i = 0; i < this->cog_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->cog(i));
  }
  
  // repeated .FileSign sign = 13;
  total_size += 1 * this->sign_size();
  for (int i = 0; i < this->sign_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->sign(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FileWorld::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const FileWorld* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const FileWorld*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void FileWorld::MergeFrom(const FileWorld& from) {
  GOOGLE_CHECK_NE(&from, this);
  sector_.MergeFrom(from.sector_);
  button_.MergeFrom(from.button_);
  enemy_.MergeFrom(from.enemy_);
  door_.MergeFrom(from.door_);
  cog_.MergeFrom(from.cog_);
  sign_.MergeFrom(from.sign_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_players_start_x(from.players_start_x());
    }
    if (from._has_bit(1)) {
      set_players_start_y(from.players_start_y());
    }
    if (from._has_bit(2)) {
      set_players_end_x(from.players_end_x());
    }
    if (from._has_bit(3)) {
      set_players_end_y(from.players_end_y());
    }
    if (from._has_bit(4)) {
      set_width(from.width());
    }
    if (from._has_bit(5)) {
      set_height(from.height());
    }
  }
  if (from._has_bits_[11 / 32] & (0xffu << (11 % 32))) {
    if (from._has_bit(11)) {
      set_unique_id(from.unique_id());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void FileWorld::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void FileWorld::CopyFrom(const FileWorld& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FileWorld::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000003f) != 0x0000003f) return false;
  
  for (int i = 0; i < sector_size(); i++) {
    if (!this->sector(i).IsInitialized()) return false;
  }
  for (int i = 0; i < button_size(); i++) {
    if (!this->button(i).IsInitialized()) return false;
  }
  for (int i = 0; i < enemy_size(); i++) {
    if (!this->enemy(i).IsInitialized()) return false;
  }
  for (int i = 0; i < door_size(); i++) {
    if (!this->door(i).IsInitialized()) return false;
  }
  for (int i = 0; i < cog_size(); i++) {
    if (!this->cog(i).IsInitialized()) return false;
  }
  for (int i = 0; i < sign_size(); i++) {
    if (!this->sign(i).IsInitialized()) return false;
  }
  return true;
}

void FileWorld::Swap(FileWorld* other) {
  if (other != this) {
    std::swap(players_start_x_, other->players_start_x_);
    std::swap(players_start_y_, other->players_start_y_);
    std::swap(players_end_x_, other->players_end_x_);
    std::swap(players_end_y_, other->players_end_y_);
    std::swap(width_, other->width_);
    std::swap(height_, other->height_);
    sector_.Swap(&other->sector_);
    button_.Swap(&other->button_);
    enemy_.Swap(&other->enemy_);
    door_.Swap(&other->door_);
    cog_.Swap(&other->cog_);
    std::swap(unique_id_, other->unique_id_);
    sign_.Swap(&other->sign_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata FileWorld::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = FileWorld_descriptor_;
  metadata.reflection = FileWorld_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

// @@protoc_insertion_point(global_scope)
