// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: world.proto

#ifndef PROTOBUF_world_2eproto__INCLUDED
#define PROTOBUF_world_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2003000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2003000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_world_2eproto();
void protobuf_AssignDesc_world_2eproto();
void protobuf_ShutdownFile_world_2eproto();

class FileEnemy;
class FileButton;
class FileDoor;
class FileCell;
class FileSector;
class FileCog;
class FileSign;
class FileWorld;

enum FileEnemy_EnemyType {
  FileEnemy_EnemyType_ENEMY_BOMBER = 0,
  FileEnemy_EnemyType_ENEMY_DOOM_MAGNET = 1,
  FileEnemy_EnemyType_ENEMY_GRENADIER = 2,
  FileEnemy_EnemyType_ENEMY_HEADACHE = 3,
  FileEnemy_EnemyType_ENEMY_POPPER = 4,
  FileEnemy_EnemyType_ENEMY_RIOT_GUN = 5,
  FileEnemy_EnemyType_ENEMY_SHOCK_HAWK = 6,
  FileEnemy_EnemyType_ENEMY_STALACBAT = 7,
  FileEnemy_EnemyType_ENEMY_WALL_CRAWLER = 8,
  FileEnemy_EnemyType_ENEMY_WHEELIGATOR = 9,
  FileEnemy_EnemyType_ENEMY_ROCKET_SPIDER = 10,
  FileEnemy_EnemyType_ENEMY_HUNTER = 11,
  FileEnemy_EnemyType_ENEMY_WALL_AVOIDER = 12,
  FileEnemy_EnemyType_ENEMY_SPIKE_BALL = 13,
  FileEnemy_EnemyType_ENEMY_CORROSION_CLOUD = 14,
  FileEnemy_EnemyType_ENEMY_BOUNCY_ROCKET_LAUNCHER = 15,
  FileEnemy_EnemyType_ENEMY_MULTI_THROW = 16
};
bool FileEnemy_EnemyType_IsValid(int value);
const FileEnemy_EnemyType FileEnemy_EnemyType_EnemyType_MIN = FileEnemy_EnemyType_ENEMY_BOMBER;
const FileEnemy_EnemyType FileEnemy_EnemyType_EnemyType_MAX = FileEnemy_EnemyType_ENEMY_MULTI_THROW;
const int FileEnemy_EnemyType_EnemyType_ARRAYSIZE = FileEnemy_EnemyType_EnemyType_MAX + 1;

const ::google::protobuf::EnumDescriptor* FileEnemy_EnemyType_descriptor();
inline const ::std::string& FileEnemy_EnemyType_Name(FileEnemy_EnemyType value) {
  return ::google::protobuf::internal::NameOfEnum(
    FileEnemy_EnemyType_descriptor(), value);
}
inline bool FileEnemy_EnemyType_Parse(
    const ::std::string& name, FileEnemy_EnemyType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FileEnemy_EnemyType>(
    FileEnemy_EnemyType_descriptor(), name, value);
}
enum FileButton_ButtonBehavior {
  FileButton_ButtonBehavior_OPEN_ALL = 0,
  FileButton_ButtonBehavior_CLOSE_ALL = 1,
  FileButton_ButtonBehavior_TOGGLE_ALL = 2
};
bool FileButton_ButtonBehavior_IsValid(int value);
const FileButton_ButtonBehavior FileButton_ButtonBehavior_ButtonBehavior_MIN = FileButton_ButtonBehavior_OPEN_ALL;
const FileButton_ButtonBehavior FileButton_ButtonBehavior_ButtonBehavior_MAX = FileButton_ButtonBehavior_TOGGLE_ALL;
const int FileButton_ButtonBehavior_ButtonBehavior_ARRAYSIZE = FileButton_ButtonBehavior_ButtonBehavior_MAX + 1;

const ::google::protobuf::EnumDescriptor* FileButton_ButtonBehavior_descriptor();
inline const ::std::string& FileButton_ButtonBehavior_Name(FileButton_ButtonBehavior value) {
  return ::google::protobuf::internal::NameOfEnum(
    FileButton_ButtonBehavior_descriptor(), value);
}
inline bool FileButton_ButtonBehavior_Parse(
    const ::std::string& name, FileButton_ButtonBehavior* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FileButton_ButtonBehavior>(
    FileButton_ButtonBehavior_descriptor(), name, value);
}
enum FileDoor_DoorState {
  FileDoor_DoorState_DOOR_OPEN = 0,
  FileDoor_DoorState_DOOR_CLOSED = 1
};
bool FileDoor_DoorState_IsValid(int value);
const FileDoor_DoorState FileDoor_DoorState_DoorState_MIN = FileDoor_DoorState_DOOR_OPEN;
const FileDoor_DoorState FileDoor_DoorState_DoorState_MAX = FileDoor_DoorState_DOOR_CLOSED;
const int FileDoor_DoorState_DoorState_ARRAYSIZE = FileDoor_DoorState_DoorState_MAX + 1;

const ::google::protobuf::EnumDescriptor* FileDoor_DoorState_descriptor();
inline const ::std::string& FileDoor_DoorState_Name(FileDoor_DoorState value) {
  return ::google::protobuf::internal::NameOfEnum(
    FileDoor_DoorState_descriptor(), value);
}
inline bool FileDoor_DoorState_Parse(
    const ::std::string& name, FileDoor_DoorState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FileDoor_DoorState>(
    FileDoor_DoorState_descriptor(), name, value);
}
enum FileDoor_DoorType {
  FileDoor_DoorType_ONE_WAY = 0,
  FileDoor_DoorType_TWO_WAY = 1
};
bool FileDoor_DoorType_IsValid(int value);
const FileDoor_DoorType FileDoor_DoorType_DoorType_MIN = FileDoor_DoorType_ONE_WAY;
const FileDoor_DoorType FileDoor_DoorType_DoorType_MAX = FileDoor_DoorType_TWO_WAY;
const int FileDoor_DoorType_DoorType_ARRAYSIZE = FileDoor_DoorType_DoorType_MAX + 1;

const ::google::protobuf::EnumDescriptor* FileDoor_DoorType_descriptor();
inline const ::std::string& FileDoor_DoorType_Name(FileDoor_DoorType value) {
  return ::google::protobuf::internal::NameOfEnum(
    FileDoor_DoorType_descriptor(), value);
}
inline bool FileDoor_DoorType_Parse(
    const ::std::string& name, FileDoor_DoorType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FileDoor_DoorType>(
    FileDoor_DoorType_descriptor(), name, value);
}
enum FileCell_CellType {
  FileCell_CellType_CELL_EMPTY = 0,
  FileCell_CellType_CELL_SOLID = 1,
  FileCell_CellType_CELL_FLOOR_DIAG_LEFT = 2,
  FileCell_CellType_CELL_FLOOR_DIAG_RIGHT = 3,
  FileCell_CellType_CELL_CEIL_DIAG_LEFT = 4,
  FileCell_CellType_CELL_CEIL_DIAG_RIGHT = 5
};
bool FileCell_CellType_IsValid(int value);
const FileCell_CellType FileCell_CellType_CellType_MIN = FileCell_CellType_CELL_EMPTY;
const FileCell_CellType FileCell_CellType_CellType_MAX = FileCell_CellType_CELL_CEIL_DIAG_RIGHT;
const int FileCell_CellType_CellType_ARRAYSIZE = FileCell_CellType_CellType_MAX + 1;

const ::google::protobuf::EnumDescriptor* FileCell_CellType_descriptor();
inline const ::std::string& FileCell_CellType_Name(FileCell_CellType value) {
  return ::google::protobuf::internal::NameOfEnum(
    FileCell_CellType_descriptor(), value);
}
inline bool FileCell_CellType_Parse(
    const ::std::string& name, FileCell_CellType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FileCell_CellType>(
    FileCell_CellType_descriptor(), name, value);
}
enum FileCell_EdgeType {
  FileCell_EdgeType_EDGE_EMPTY = 0,
  FileCell_EdgeType_EDGE_NORMAL = 1,
  FileCell_EdgeType_EDGE_STICKY = 2,
  FileCell_EdgeType_EDGE_SLIPPERY = 3
};
bool FileCell_EdgeType_IsValid(int value);
const FileCell_EdgeType FileCell_EdgeType_EdgeType_MIN = FileCell_EdgeType_EDGE_EMPTY;
const FileCell_EdgeType FileCell_EdgeType_EdgeType_MAX = FileCell_EdgeType_EDGE_SLIPPERY;
const int FileCell_EdgeType_EdgeType_ARRAYSIZE = FileCell_EdgeType_EdgeType_MAX + 1;

const ::google::protobuf::EnumDescriptor* FileCell_EdgeType_descriptor();
inline const ::std::string& FileCell_EdgeType_Name(FileCell_EdgeType value) {
  return ::google::protobuf::internal::NameOfEnum(
    FileCell_EdgeType_descriptor(), value);
}
inline bool FileCell_EdgeType_Parse(
    const ::std::string& name, FileCell_EdgeType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FileCell_EdgeType>(
    FileCell_EdgeType_descriptor(), name, value);
}
enum FileColor {
  NEUTRAL = 0,
  RED = 1,
  BLUE = 2
};
bool FileColor_IsValid(int value);
const FileColor FileColor_MIN = NEUTRAL;
const FileColor FileColor_MAX = BLUE;
const int FileColor_ARRAYSIZE = FileColor_MAX + 1;

const ::google::protobuf::EnumDescriptor* FileColor_descriptor();
inline const ::std::string& FileColor_Name(FileColor value) {
  return ::google::protobuf::internal::NameOfEnum(
    FileColor_descriptor(), value);
}
inline bool FileColor_Parse(
    const ::std::string& name, FileColor* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FileColor>(
    FileColor_descriptor(), name, value);
}
// ===================================================================

class FileEnemy : public ::google::protobuf::Message {
 public:
  FileEnemy();
  virtual ~FileEnemy();
  
  FileEnemy(const FileEnemy& from);
  
  inline FileEnemy& operator=(const FileEnemy& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const FileEnemy& default_instance();
  
  void Swap(FileEnemy* other);
  
  // implements Message ----------------------------------------------
  
  FileEnemy* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FileEnemy& from);
  void MergeFrom(const FileEnemy& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef FileEnemy_EnemyType EnemyType;
  static const EnemyType ENEMY_BOMBER = FileEnemy_EnemyType_ENEMY_BOMBER;
  static const EnemyType ENEMY_DOOM_MAGNET = FileEnemy_EnemyType_ENEMY_DOOM_MAGNET;
  static const EnemyType ENEMY_GRENADIER = FileEnemy_EnemyType_ENEMY_GRENADIER;
  static const EnemyType ENEMY_HEADACHE = FileEnemy_EnemyType_ENEMY_HEADACHE;
  static const EnemyType ENEMY_POPPER = FileEnemy_EnemyType_ENEMY_POPPER;
  static const EnemyType ENEMY_RIOT_GUN = FileEnemy_EnemyType_ENEMY_RIOT_GUN;
  static const EnemyType ENEMY_SHOCK_HAWK = FileEnemy_EnemyType_ENEMY_SHOCK_HAWK;
  static const EnemyType ENEMY_STALACBAT = FileEnemy_EnemyType_ENEMY_STALACBAT;
  static const EnemyType ENEMY_WALL_CRAWLER = FileEnemy_EnemyType_ENEMY_WALL_CRAWLER;
  static const EnemyType ENEMY_WHEELIGATOR = FileEnemy_EnemyType_ENEMY_WHEELIGATOR;
  static const EnemyType ENEMY_ROCKET_SPIDER = FileEnemy_EnemyType_ENEMY_ROCKET_SPIDER;
  static const EnemyType ENEMY_HUNTER = FileEnemy_EnemyType_ENEMY_HUNTER;
  static const EnemyType ENEMY_WALL_AVOIDER = FileEnemy_EnemyType_ENEMY_WALL_AVOIDER;
  static const EnemyType ENEMY_SPIKE_BALL = FileEnemy_EnemyType_ENEMY_SPIKE_BALL;
  static const EnemyType ENEMY_CORROSION_CLOUD = FileEnemy_EnemyType_ENEMY_CORROSION_CLOUD;
  static const EnemyType ENEMY_BOUNCY_ROCKET_LAUNCHER = FileEnemy_EnemyType_ENEMY_BOUNCY_ROCKET_LAUNCHER;
  static const EnemyType ENEMY_MULTI_THROW = FileEnemy_EnemyType_ENEMY_MULTI_THROW;
  static inline bool EnemyType_IsValid(int value) {
    return FileEnemy_EnemyType_IsValid(value);
  }
  static const EnemyType EnemyType_MIN =
    FileEnemy_EnemyType_EnemyType_MIN;
  static const EnemyType EnemyType_MAX =
    FileEnemy_EnemyType_EnemyType_MAX;
  static const int EnemyType_ARRAYSIZE =
    FileEnemy_EnemyType_EnemyType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  EnemyType_descriptor() {
    return FileEnemy_EnemyType_descriptor();
  }
  static inline const ::std::string& EnemyType_Name(EnemyType value) {
    return FileEnemy_EnemyType_Name(value);
  }
  static inline bool EnemyType_Parse(const ::std::string& name,
      EnemyType* value) {
    return FileEnemy_EnemyType_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // required float center_x = 1;
  inline bool has_center_x() const;
  inline void clear_center_x();
  static const int kCenterXFieldNumber = 1;
  inline float center_x() const;
  inline void set_center_x(float value);
  
  // required float center_y = 2;
  inline bool has_center_y() const;
  inline void clear_center_y();
  static const int kCenterYFieldNumber = 2;
  inline float center_y() const;
  inline void set_center_y(float value);
  
  // required float angle = 3;
  inline bool has_angle() const;
  inline void clear_angle();
  static const int kAngleFieldNumber = 3;
  inline float angle() const;
  inline void set_angle(float value);
  
  // required .FileEnemy.EnemyType type = 4;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 4;
  inline ::FileEnemy_EnemyType type() const;
  inline void set_type(::FileEnemy_EnemyType value);
  
  // required .FileColor color = 5;
  inline bool has_color() const;
  inline void clear_color();
  static const int kColorFieldNumber = 5;
  inline FileColor color() const;
  inline void set_color(FileColor value);
  
  // @@protoc_insertion_point(class_scope:FileEnemy)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  float center_x_;
  float center_y_;
  float angle_;
  int type_;
  int color_;
  friend void  protobuf_AddDesc_world_2eproto();
  friend void protobuf_AssignDesc_world_2eproto();
  friend void protobuf_ShutdownFile_world_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static FileEnemy* default_instance_;
};
// -------------------------------------------------------------------

class FileButton : public ::google::protobuf::Message {
 public:
  FileButton();
  virtual ~FileButton();
  
  FileButton(const FileButton& from);
  
  inline FileButton& operator=(const FileButton& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const FileButton& default_instance();
  
  void Swap(FileButton* other);
  
  // implements Message ----------------------------------------------
  
  FileButton* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FileButton& from);
  void MergeFrom(const FileButton& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef FileButton_ButtonBehavior ButtonBehavior;
  static const ButtonBehavior OPEN_ALL = FileButton_ButtonBehavior_OPEN_ALL;
  static const ButtonBehavior CLOSE_ALL = FileButton_ButtonBehavior_CLOSE_ALL;
  static const ButtonBehavior TOGGLE_ALL = FileButton_ButtonBehavior_TOGGLE_ALL;
  static inline bool ButtonBehavior_IsValid(int value) {
    return FileButton_ButtonBehavior_IsValid(value);
  }
  static const ButtonBehavior ButtonBehavior_MIN =
    FileButton_ButtonBehavior_ButtonBehavior_MIN;
  static const ButtonBehavior ButtonBehavior_MAX =
    FileButton_ButtonBehavior_ButtonBehavior_MAX;
  static const int ButtonBehavior_ARRAYSIZE =
    FileButton_ButtonBehavior_ButtonBehavior_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ButtonBehavior_descriptor() {
    return FileButton_ButtonBehavior_descriptor();
  }
  static inline const ::std::string& ButtonBehavior_Name(ButtonBehavior value) {
    return FileButton_ButtonBehavior_Name(value);
  }
  static inline bool ButtonBehavior_Parse(const ::std::string& name,
      ButtonBehavior* value) {
    return FileButton_ButtonBehavior_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // required float position_x = 1;
  inline bool has_position_x() const;
  inline void clear_position_x();
  static const int kPositionXFieldNumber = 1;
  inline float position_x() const;
  inline void set_position_x(float value);
  
  // required float position_y = 2;
  inline bool has_position_y() const;
  inline void clear_position_y();
  static const int kPositionYFieldNumber = 2;
  inline float position_y() const;
  inline void set_position_y(float value);
  
  // required bool is_visible = 3;
  inline bool has_is_visible() const;
  inline void clear_is_visible();
  static const int kIsVisibleFieldNumber = 3;
  inline bool is_visible() const;
  inline void set_is_visible(bool value);
  
  // required .FileButton.ButtonBehavior behavior = 4;
  inline bool has_behavior() const;
  inline void clear_behavior();
  static const int kBehaviorFieldNumber = 4;
  inline ::FileButton_ButtonBehavior behavior() const;
  inline void set_behavior(::FileButton_ButtonBehavior value);
  
  // required .FileColor color = 5;
  inline bool has_color() const;
  inline void clear_color();
  static const int kColorFieldNumber = 5;
  inline FileColor color() const;
  inline void set_color(FileColor value);
  
  // repeated int32 door_index = 6;
  inline int door_index_size() const;
  inline void clear_door_index();
  static const int kDoorIndexFieldNumber = 6;
  inline ::google::protobuf::int32 door_index(int index) const;
  inline void set_door_index(int index, ::google::protobuf::int32 value);
  inline void add_door_index(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      door_index() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_door_index();
  
  // @@protoc_insertion_point(class_scope:FileButton)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  float position_x_;
  float position_y_;
  bool is_visible_;
  int behavior_;
  int color_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > door_index_;
  friend void  protobuf_AddDesc_world_2eproto();
  friend void protobuf_AssignDesc_world_2eproto();
  friend void protobuf_ShutdownFile_world_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static FileButton* default_instance_;
};
// -------------------------------------------------------------------

class FileDoor : public ::google::protobuf::Message {
 public:
  FileDoor();
  virtual ~FileDoor();
  
  FileDoor(const FileDoor& from);
  
  inline FileDoor& operator=(const FileDoor& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const FileDoor& default_instance();
  
  void Swap(FileDoor* other);
  
  // implements Message ----------------------------------------------
  
  FileDoor* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FileDoor& from);
  void MergeFrom(const FileDoor& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef FileDoor_DoorState DoorState;
  static const DoorState DOOR_OPEN = FileDoor_DoorState_DOOR_OPEN;
  static const DoorState DOOR_CLOSED = FileDoor_DoorState_DOOR_CLOSED;
  static inline bool DoorState_IsValid(int value) {
    return FileDoor_DoorState_IsValid(value);
  }
  static const DoorState DoorState_MIN =
    FileDoor_DoorState_DoorState_MIN;
  static const DoorState DoorState_MAX =
    FileDoor_DoorState_DoorState_MAX;
  static const int DoorState_ARRAYSIZE =
    FileDoor_DoorState_DoorState_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  DoorState_descriptor() {
    return FileDoor_DoorState_descriptor();
  }
  static inline const ::std::string& DoorState_Name(DoorState value) {
    return FileDoor_DoorState_Name(value);
  }
  static inline bool DoorState_Parse(const ::std::string& name,
      DoorState* value) {
    return FileDoor_DoorState_Parse(name, value);
  }
  
  typedef FileDoor_DoorType DoorType;
  static const DoorType ONE_WAY = FileDoor_DoorType_ONE_WAY;
  static const DoorType TWO_WAY = FileDoor_DoorType_TWO_WAY;
  static inline bool DoorType_IsValid(int value) {
    return FileDoor_DoorType_IsValid(value);
  }
  static const DoorType DoorType_MIN =
    FileDoor_DoorType_DoorType_MIN;
  static const DoorType DoorType_MAX =
    FileDoor_DoorType_DoorType_MAX;
  static const int DoorType_ARRAYSIZE =
    FileDoor_DoorType_DoorType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  DoorType_descriptor() {
    return FileDoor_DoorType_descriptor();
  }
  static inline const ::std::string& DoorType_Name(DoorType value) {
    return FileDoor_DoorType_Name(value);
  }
  static inline bool DoorType_Parse(const ::std::string& name,
      DoorType* value) {
    return FileDoor_DoorType_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // required int32 start_x = 1;
  inline bool has_start_x() const;
  inline void clear_start_x();
  static const int kStartXFieldNumber = 1;
  inline ::google::protobuf::int32 start_x() const;
  inline void set_start_x(::google::protobuf::int32 value);
  
  // required int32 start_y = 2;
  inline bool has_start_y() const;
  inline void clear_start_y();
  static const int kStartYFieldNumber = 2;
  inline ::google::protobuf::int32 start_y() const;
  inline void set_start_y(::google::protobuf::int32 value);
  
  // required int32 end_x = 3;
  inline bool has_end_x() const;
  inline void clear_end_x();
  static const int kEndXFieldNumber = 3;
  inline ::google::protobuf::int32 end_x() const;
  inline void set_end_x(::google::protobuf::int32 value);
  
  // required int32 end_y = 4;
  inline bool has_end_y() const;
  inline void clear_end_y();
  static const int kEndYFieldNumber = 4;
  inline ::google::protobuf::int32 end_y() const;
  inline void set_end_y(::google::protobuf::int32 value);
  
  // required .FileDoor.DoorState state = 5;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 5;
  inline ::FileDoor_DoorState state() const;
  inline void set_state(::FileDoor_DoorState value);
  
  // required .FileDoor.DoorType type = 6;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 6;
  inline ::FileDoor_DoorType type() const;
  inline void set_type(::FileDoor_DoorType value);
  
  // required .FileColor color = 7;
  inline bool has_color() const;
  inline void clear_color();
  static const int kColorFieldNumber = 7;
  inline FileColor color() const;
  inline void set_color(FileColor value);
  
  // @@protoc_insertion_point(class_scope:FileDoor)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::int32 start_x_;
  ::google::protobuf::int32 start_y_;
  ::google::protobuf::int32 end_x_;
  ::google::protobuf::int32 end_y_;
  int state_;
  int type_;
  int color_;
  friend void  protobuf_AddDesc_world_2eproto();
  friend void protobuf_AssignDesc_world_2eproto();
  friend void protobuf_ShutdownFile_world_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static FileDoor* default_instance_;
};
// -------------------------------------------------------------------

class FileCell : public ::google::protobuf::Message {
 public:
  FileCell();
  virtual ~FileCell();
  
  FileCell(const FileCell& from);
  
  inline FileCell& operator=(const FileCell& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const FileCell& default_instance();
  
  void Swap(FileCell* other);
  
  // implements Message ----------------------------------------------
  
  FileCell* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FileCell& from);
  void MergeFrom(const FileCell& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef FileCell_CellType CellType;
  static const CellType CELL_EMPTY = FileCell_CellType_CELL_EMPTY;
  static const CellType CELL_SOLID = FileCell_CellType_CELL_SOLID;
  static const CellType CELL_FLOOR_DIAG_LEFT = FileCell_CellType_CELL_FLOOR_DIAG_LEFT;
  static const CellType CELL_FLOOR_DIAG_RIGHT = FileCell_CellType_CELL_FLOOR_DIAG_RIGHT;
  static const CellType CELL_CEIL_DIAG_LEFT = FileCell_CellType_CELL_CEIL_DIAG_LEFT;
  static const CellType CELL_CEIL_DIAG_RIGHT = FileCell_CellType_CELL_CEIL_DIAG_RIGHT;
  static inline bool CellType_IsValid(int value) {
    return FileCell_CellType_IsValid(value);
  }
  static const CellType CellType_MIN =
    FileCell_CellType_CellType_MIN;
  static const CellType CellType_MAX =
    FileCell_CellType_CellType_MAX;
  static const int CellType_ARRAYSIZE =
    FileCell_CellType_CellType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  CellType_descriptor() {
    return FileCell_CellType_descriptor();
  }
  static inline const ::std::string& CellType_Name(CellType value) {
    return FileCell_CellType_Name(value);
  }
  static inline bool CellType_Parse(const ::std::string& name,
      CellType* value) {
    return FileCell_CellType_Parse(name, value);
  }
  
  typedef FileCell_EdgeType EdgeType;
  static const EdgeType EDGE_EMPTY = FileCell_EdgeType_EDGE_EMPTY;
  static const EdgeType EDGE_NORMAL = FileCell_EdgeType_EDGE_NORMAL;
  static const EdgeType EDGE_STICKY = FileCell_EdgeType_EDGE_STICKY;
  static const EdgeType EDGE_SLIPPERY = FileCell_EdgeType_EDGE_SLIPPERY;
  static inline bool EdgeType_IsValid(int value) {
    return FileCell_EdgeType_IsValid(value);
  }
  static const EdgeType EdgeType_MIN =
    FileCell_EdgeType_EdgeType_MIN;
  static const EdgeType EdgeType_MAX =
    FileCell_EdgeType_EdgeType_MAX;
  static const int EdgeType_ARRAYSIZE =
    FileCell_EdgeType_EdgeType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  EdgeType_descriptor() {
    return FileCell_EdgeType_descriptor();
  }
  static inline const ::std::string& EdgeType_Name(EdgeType value) {
    return FileCell_EdgeType_Name(value);
  }
  static inline bool EdgeType_Parse(const ::std::string& name,
      EdgeType* value) {
    return FileCell_EdgeType_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // required .FileCell.CellType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::FileCell_CellType type() const;
  inline void set_type(::FileCell_CellType value);
  
  // repeated .FileCell.EdgeType edge = 2;
  inline int edge_size() const;
  inline void clear_edge();
  static const int kEdgeFieldNumber = 2;
  inline ::FileCell_EdgeType edge(int index) const;
  inline void set_edge(int index, ::FileCell_EdgeType value);
  inline void add_edge(::FileCell_EdgeType value);
  inline const ::google::protobuf::RepeatedField<int>& edge() const;
  inline ::google::protobuf::RepeatedField<int>* mutable_edge();
  
  // @@protoc_insertion_point(class_scope:FileCell)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  int type_;
  ::google::protobuf::RepeatedField<int> edge_;
  friend void  protobuf_AddDesc_world_2eproto();
  friend void protobuf_AssignDesc_world_2eproto();
  friend void protobuf_ShutdownFile_world_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static FileCell* default_instance_;
};
// -------------------------------------------------------------------

class FileSector : public ::google::protobuf::Message {
 public:
  FileSector();
  virtual ~FileSector();
  
  FileSector(const FileSector& from);
  
  inline FileSector& operator=(const FileSector& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const FileSector& default_instance();
  
  void Swap(FileSector* other);
  
  // implements Message ----------------------------------------------
  
  FileSector* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FileSector& from);
  void MergeFrom(const FileSector& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .FileCell cell = 1;
  inline int cell_size() const;
  inline void clear_cell();
  static const int kCellFieldNumber = 1;
  inline const ::FileCell& cell(int index) const;
  inline ::FileCell* mutable_cell(int index);
  inline ::FileCell* add_cell();
  inline const ::google::protobuf::RepeatedPtrField< ::FileCell >&
      cell() const;
  inline ::google::protobuf::RepeatedPtrField< ::FileCell >*
      mutable_cell();
  
  // @@protoc_insertion_point(class_scope:FileSector)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::FileCell > cell_;
  friend void  protobuf_AddDesc_world_2eproto();
  friend void protobuf_AssignDesc_world_2eproto();
  friend void protobuf_ShutdownFile_world_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static FileSector* default_instance_;
};
// -------------------------------------------------------------------

class FileCog : public ::google::protobuf::Message {
 public:
  FileCog();
  virtual ~FileCog();
  
  FileCog(const FileCog& from);
  
  inline FileCog& operator=(const FileCog& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const FileCog& default_instance();
  
  void Swap(FileCog* other);
  
  // implements Message ----------------------------------------------
  
  FileCog* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FileCog& from);
  void MergeFrom(const FileCog& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required float cog_x = 1;
  inline bool has_cog_x() const;
  inline void clear_cog_x();
  static const int kCogXFieldNumber = 1;
  inline float cog_x() const;
  inline void set_cog_x(float value);
  
  // required float cog_y = 2;
  inline bool has_cog_y() const;
  inline void clear_cog_y();
  static const int kCogYFieldNumber = 2;
  inline float cog_y() const;
  inline void set_cog_y(float value);
  
  // @@protoc_insertion_point(class_scope:FileCog)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  float cog_x_;
  float cog_y_;
  friend void  protobuf_AddDesc_world_2eproto();
  friend void protobuf_AssignDesc_world_2eproto();
  friend void protobuf_ShutdownFile_world_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static FileCog* default_instance_;
};
// -------------------------------------------------------------------

class FileSign : public ::google::protobuf::Message {
 public:
  FileSign();
  virtual ~FileSign();
  
  FileSign(const FileSign& from);
  
  inline FileSign& operator=(const FileSign& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const FileSign& default_instance();
  
  void Swap(FileSign* other);
  
  // implements Message ----------------------------------------------
  
  FileSign* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FileSign& from);
  void MergeFrom(const FileSign& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required float sign_x = 1;
  inline bool has_sign_x() const;
  inline void clear_sign_x();
  static const int kSignXFieldNumber = 1;
  inline float sign_x() const;
  inline void set_sign_x(float value);
  
  // required float sign_y = 2;
  inline bool has_sign_y() const;
  inline void clear_sign_y();
  static const int kSignYFieldNumber = 2;
  inline float sign_y() const;
  inline void set_sign_y(float value);
  
  // required string text = 3;
  inline bool has_text() const;
  inline void clear_text();
  static const int kTextFieldNumber = 3;
  inline const ::std::string& text() const;
  inline void set_text(const ::std::string& value);
  inline void set_text(const char* value);
  inline void set_text(const char* value, size_t size);
  inline ::std::string* mutable_text();
  
  // @@protoc_insertion_point(class_scope:FileSign)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  float sign_x_;
  float sign_y_;
  ::std::string* text_;
  static const ::std::string _default_text_;
  friend void  protobuf_AddDesc_world_2eproto();
  friend void protobuf_AssignDesc_world_2eproto();
  friend void protobuf_ShutdownFile_world_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static FileSign* default_instance_;
};
// -------------------------------------------------------------------

class FileWorld : public ::google::protobuf::Message {
 public:
  FileWorld();
  virtual ~FileWorld();
  
  FileWorld(const FileWorld& from);
  
  inline FileWorld& operator=(const FileWorld& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const FileWorld& default_instance();
  
  void Swap(FileWorld* other);
  
  // implements Message ----------------------------------------------
  
  FileWorld* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FileWorld& from);
  void MergeFrom(const FileWorld& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 players_start_x = 1;
  inline bool has_players_start_x() const;
  inline void clear_players_start_x();
  static const int kPlayersStartXFieldNumber = 1;
  inline ::google::protobuf::int32 players_start_x() const;
  inline void set_players_start_x(::google::protobuf::int32 value);
  
  // required int32 players_start_y = 2;
  inline bool has_players_start_y() const;
  inline void clear_players_start_y();
  static const int kPlayersStartYFieldNumber = 2;
  inline ::google::protobuf::int32 players_start_y() const;
  inline void set_players_start_y(::google::protobuf::int32 value);
  
  // required int32 players_end_x = 3;
  inline bool has_players_end_x() const;
  inline void clear_players_end_x();
  static const int kPlayersEndXFieldNumber = 3;
  inline ::google::protobuf::int32 players_end_x() const;
  inline void set_players_end_x(::google::protobuf::int32 value);
  
  // required int32 players_end_y = 4;
  inline bool has_players_end_y() const;
  inline void clear_players_end_y();
  static const int kPlayersEndYFieldNumber = 4;
  inline ::google::protobuf::int32 players_end_y() const;
  inline void set_players_end_y(::google::protobuf::int32 value);
  
  // required int32 width = 5;
  inline bool has_width() const;
  inline void clear_width();
  static const int kWidthFieldNumber = 5;
  inline ::google::protobuf::int32 width() const;
  inline void set_width(::google::protobuf::int32 value);
  
  // required int32 height = 6;
  inline bool has_height() const;
  inline void clear_height();
  static const int kHeightFieldNumber = 6;
  inline ::google::protobuf::int32 height() const;
  inline void set_height(::google::protobuf::int32 value);
  
  // repeated .FileSector sector = 7;
  inline int sector_size() const;
  inline void clear_sector();
  static const int kSectorFieldNumber = 7;
  inline const ::FileSector& sector(int index) const;
  inline ::FileSector* mutable_sector(int index);
  inline ::FileSector* add_sector();
  inline const ::google::protobuf::RepeatedPtrField< ::FileSector >&
      sector() const;
  inline ::google::protobuf::RepeatedPtrField< ::FileSector >*
      mutable_sector();
  
  // repeated .FileButton button = 8;
  inline int button_size() const;
  inline void clear_button();
  static const int kButtonFieldNumber = 8;
  inline const ::FileButton& button(int index) const;
  inline ::FileButton* mutable_button(int index);
  inline ::FileButton* add_button();
  inline const ::google::protobuf::RepeatedPtrField< ::FileButton >&
      button() const;
  inline ::google::protobuf::RepeatedPtrField< ::FileButton >*
      mutable_button();
  
  // repeated .FileEnemy enemy = 9;
  inline int enemy_size() const;
  inline void clear_enemy();
  static const int kEnemyFieldNumber = 9;
  inline const ::FileEnemy& enemy(int index) const;
  inline ::FileEnemy* mutable_enemy(int index);
  inline ::FileEnemy* add_enemy();
  inline const ::google::protobuf::RepeatedPtrField< ::FileEnemy >&
      enemy() const;
  inline ::google::protobuf::RepeatedPtrField< ::FileEnemy >*
      mutable_enemy();
  
  // repeated .FileDoor door = 10;
  inline int door_size() const;
  inline void clear_door();
  static const int kDoorFieldNumber = 10;
  inline const ::FileDoor& door(int index) const;
  inline ::FileDoor* mutable_door(int index);
  inline ::FileDoor* add_door();
  inline const ::google::protobuf::RepeatedPtrField< ::FileDoor >&
      door() const;
  inline ::google::protobuf::RepeatedPtrField< ::FileDoor >*
      mutable_door();
  
  // repeated .FileCog cog = 11;
  inline int cog_size() const;
  inline void clear_cog();
  static const int kCogFieldNumber = 11;
  inline const ::FileCog& cog(int index) const;
  inline ::FileCog* mutable_cog(int index);
  inline ::FileCog* add_cog();
  inline const ::google::protobuf::RepeatedPtrField< ::FileCog >&
      cog() const;
  inline ::google::protobuf::RepeatedPtrField< ::FileCog >*
      mutable_cog();
  
  // optional int32 unique_id = 12;
  inline bool has_unique_id() const;
  inline void clear_unique_id();
  static const int kUniqueIdFieldNumber = 12;
  inline ::google::protobuf::int32 unique_id() const;
  inline void set_unique_id(::google::protobuf::int32 value);
  
  // repeated .FileSign sign = 13;
  inline int sign_size() const;
  inline void clear_sign();
  static const int kSignFieldNumber = 13;
  inline const ::FileSign& sign(int index) const;
  inline ::FileSign* mutable_sign(int index);
  inline ::FileSign* add_sign();
  inline const ::google::protobuf::RepeatedPtrField< ::FileSign >&
      sign() const;
  inline ::google::protobuf::RepeatedPtrField< ::FileSign >*
      mutable_sign();
  
  // @@protoc_insertion_point(class_scope:FileWorld)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::int32 players_start_x_;
  ::google::protobuf::int32 players_start_y_;
  ::google::protobuf::int32 players_end_x_;
  ::google::protobuf::int32 players_end_y_;
  ::google::protobuf::int32 width_;
  ::google::protobuf::int32 height_;
  ::google::protobuf::RepeatedPtrField< ::FileSector > sector_;
  ::google::protobuf::RepeatedPtrField< ::FileButton > button_;
  ::google::protobuf::RepeatedPtrField< ::FileEnemy > enemy_;
  ::google::protobuf::RepeatedPtrField< ::FileDoor > door_;
  ::google::protobuf::RepeatedPtrField< ::FileCog > cog_;
  ::google::protobuf::int32 unique_id_;
  ::google::protobuf::RepeatedPtrField< ::FileSign > sign_;
  friend void  protobuf_AddDesc_world_2eproto();
  friend void protobuf_AssignDesc_world_2eproto();
  friend void protobuf_ShutdownFile_world_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(13 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static FileWorld* default_instance_;
};
// ===================================================================


// ===================================================================

// FileEnemy

// required float center_x = 1;
inline bool FileEnemy::has_center_x() const {
  return _has_bit(0);
}
inline void FileEnemy::clear_center_x() {
  center_x_ = 0;
  _clear_bit(0);
}
inline float FileEnemy::center_x() const {
  return center_x_;
}
inline void FileEnemy::set_center_x(float value) {
  _set_bit(0);
  center_x_ = value;
}

// required float center_y = 2;
inline bool FileEnemy::has_center_y() const {
  return _has_bit(1);
}
inline void FileEnemy::clear_center_y() {
  center_y_ = 0;
  _clear_bit(1);
}
inline float FileEnemy::center_y() const {
  return center_y_;
}
inline void FileEnemy::set_center_y(float value) {
  _set_bit(1);
  center_y_ = value;
}

// required float angle = 3;
inline bool FileEnemy::has_angle() const {
  return _has_bit(2);
}
inline void FileEnemy::clear_angle() {
  angle_ = 0;
  _clear_bit(2);
}
inline float FileEnemy::angle() const {
  return angle_;
}
inline void FileEnemy::set_angle(float value) {
  _set_bit(2);
  angle_ = value;
}

// required .FileEnemy.EnemyType type = 4;
inline bool FileEnemy::has_type() const {
  return _has_bit(3);
}
inline void FileEnemy::clear_type() {
  type_ = 0;
  _clear_bit(3);
}
inline ::FileEnemy_EnemyType FileEnemy::type() const {
  return static_cast< ::FileEnemy_EnemyType >(type_);
}
inline void FileEnemy::set_type(::FileEnemy_EnemyType value) {
  GOOGLE_DCHECK(::FileEnemy_EnemyType_IsValid(value));
  _set_bit(3);
  type_ = value;
}

// required .FileColor color = 5;
inline bool FileEnemy::has_color() const {
  return _has_bit(4);
}
inline void FileEnemy::clear_color() {
  color_ = 0;
  _clear_bit(4);
}
inline FileColor FileEnemy::color() const {
  return static_cast< FileColor >(color_);
}
inline void FileEnemy::set_color(FileColor value) {
  GOOGLE_DCHECK(FileColor_IsValid(value));
  _set_bit(4);
  color_ = value;
}

// -------------------------------------------------------------------

// FileButton

// required float position_x = 1;
inline bool FileButton::has_position_x() const {
  return _has_bit(0);
}
inline void FileButton::clear_position_x() {
  position_x_ = 0;
  _clear_bit(0);
}
inline float FileButton::position_x() const {
  return position_x_;
}
inline void FileButton::set_position_x(float value) {
  _set_bit(0);
  position_x_ = value;
}

// required float position_y = 2;
inline bool FileButton::has_position_y() const {
  return _has_bit(1);
}
inline void FileButton::clear_position_y() {
  position_y_ = 0;
  _clear_bit(1);
}
inline float FileButton::position_y() const {
  return position_y_;
}
inline void FileButton::set_position_y(float value) {
  _set_bit(1);
  position_y_ = value;
}

// required bool is_visible = 3;
inline bool FileButton::has_is_visible() const {
  return _has_bit(2);
}
inline void FileButton::clear_is_visible() {
  is_visible_ = false;
  _clear_bit(2);
}
inline bool FileButton::is_visible() const {
  return is_visible_;
}
inline void FileButton::set_is_visible(bool value) {
  _set_bit(2);
  is_visible_ = value;
}

// required .FileButton.ButtonBehavior behavior = 4;
inline bool FileButton::has_behavior() const {
  return _has_bit(3);
}
inline void FileButton::clear_behavior() {
  behavior_ = 0;
  _clear_bit(3);
}
inline ::FileButton_ButtonBehavior FileButton::behavior() const {
  return static_cast< ::FileButton_ButtonBehavior >(behavior_);
}
inline void FileButton::set_behavior(::FileButton_ButtonBehavior value) {
  GOOGLE_DCHECK(::FileButton_ButtonBehavior_IsValid(value));
  _set_bit(3);
  behavior_ = value;
}

// required .FileColor color = 5;
inline bool FileButton::has_color() const {
  return _has_bit(4);
}
inline void FileButton::clear_color() {
  color_ = 0;
  _clear_bit(4);
}
inline FileColor FileButton::color() const {
  return static_cast< FileColor >(color_);
}
inline void FileButton::set_color(FileColor value) {
  GOOGLE_DCHECK(FileColor_IsValid(value));
  _set_bit(4);
  color_ = value;
}

// repeated int32 door_index = 6;
inline int FileButton::door_index_size() const {
  return door_index_.size();
}
inline void FileButton::clear_door_index() {
  door_index_.Clear();
}
inline ::google::protobuf::int32 FileButton::door_index(int index) const {
  return door_index_.Get(index);
}
inline void FileButton::set_door_index(int index, ::google::protobuf::int32 value) {
  door_index_.Set(index, value);
}
inline void FileButton::add_door_index(::google::protobuf::int32 value) {
  door_index_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
FileButton::door_index() const {
  return door_index_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
FileButton::mutable_door_index() {
  return &door_index_;
}

// -------------------------------------------------------------------

// FileDoor

// required int32 start_x = 1;
inline bool FileDoor::has_start_x() const {
  return _has_bit(0);
}
inline void FileDoor::clear_start_x() {
  start_x_ = 0;
  _clear_bit(0);
}
inline ::google::protobuf::int32 FileDoor::start_x() const {
  return start_x_;
}
inline void FileDoor::set_start_x(::google::protobuf::int32 value) {
  _set_bit(0);
  start_x_ = value;
}

// required int32 start_y = 2;
inline bool FileDoor::has_start_y() const {
  return _has_bit(1);
}
inline void FileDoor::clear_start_y() {
  start_y_ = 0;
  _clear_bit(1);
}
inline ::google::protobuf::int32 FileDoor::start_y() const {
  return start_y_;
}
inline void FileDoor::set_start_y(::google::protobuf::int32 value) {
  _set_bit(1);
  start_y_ = value;
}

// required int32 end_x = 3;
inline bool FileDoor::has_end_x() const {
  return _has_bit(2);
}
inline void FileDoor::clear_end_x() {
  end_x_ = 0;
  _clear_bit(2);
}
inline ::google::protobuf::int32 FileDoor::end_x() const {
  return end_x_;
}
inline void FileDoor::set_end_x(::google::protobuf::int32 value) {
  _set_bit(2);
  end_x_ = value;
}

// required int32 end_y = 4;
inline bool FileDoor::has_end_y() const {
  return _has_bit(3);
}
inline void FileDoor::clear_end_y() {
  end_y_ = 0;
  _clear_bit(3);
}
inline ::google::protobuf::int32 FileDoor::end_y() const {
  return end_y_;
}
inline void FileDoor::set_end_y(::google::protobuf::int32 value) {
  _set_bit(3);
  end_y_ = value;
}

// required .FileDoor.DoorState state = 5;
inline bool FileDoor::has_state() const {
  return _has_bit(4);
}
inline void FileDoor::clear_state() {
  state_ = 0;
  _clear_bit(4);
}
inline ::FileDoor_DoorState FileDoor::state() const {
  return static_cast< ::FileDoor_DoorState >(state_);
}
inline void FileDoor::set_state(::FileDoor_DoorState value) {
  GOOGLE_DCHECK(::FileDoor_DoorState_IsValid(value));
  _set_bit(4);
  state_ = value;
}

// required .FileDoor.DoorType type = 6;
inline bool FileDoor::has_type() const {
  return _has_bit(5);
}
inline void FileDoor::clear_type() {
  type_ = 0;
  _clear_bit(5);
}
inline ::FileDoor_DoorType FileDoor::type() const {
  return static_cast< ::FileDoor_DoorType >(type_);
}
inline void FileDoor::set_type(::FileDoor_DoorType value) {
  GOOGLE_DCHECK(::FileDoor_DoorType_IsValid(value));
  _set_bit(5);
  type_ = value;
}

// required .FileColor color = 7;
inline bool FileDoor::has_color() const {
  return _has_bit(6);
}
inline void FileDoor::clear_color() {
  color_ = 0;
  _clear_bit(6);
}
inline FileColor FileDoor::color() const {
  return static_cast< FileColor >(color_);
}
inline void FileDoor::set_color(FileColor value) {
  GOOGLE_DCHECK(FileColor_IsValid(value));
  _set_bit(6);
  color_ = value;
}

// -------------------------------------------------------------------

// FileCell

// required .FileCell.CellType type = 1;
inline bool FileCell::has_type() const {
  return _has_bit(0);
}
inline void FileCell::clear_type() {
  type_ = 0;
  _clear_bit(0);
}
inline ::FileCell_CellType FileCell::type() const {
  return static_cast< ::FileCell_CellType >(type_);
}
inline void FileCell::set_type(::FileCell_CellType value) {
  GOOGLE_DCHECK(::FileCell_CellType_IsValid(value));
  _set_bit(0);
  type_ = value;
}

// repeated .FileCell.EdgeType edge = 2;
inline int FileCell::edge_size() const {
  return edge_.size();
}
inline void FileCell::clear_edge() {
  edge_.Clear();
}
inline ::FileCell_EdgeType FileCell::edge(int index) const {
  return static_cast< ::FileCell_EdgeType >(edge_.Get(index));
}
inline void FileCell::set_edge(int index, ::FileCell_EdgeType value) {
  GOOGLE_DCHECK(::FileCell_EdgeType_IsValid(value));
  edge_.Set(index, value);
}
inline void FileCell::add_edge(::FileCell_EdgeType value) {
  GOOGLE_DCHECK(::FileCell_EdgeType_IsValid(value));
  edge_.Add(value);
}
inline const ::google::protobuf::RepeatedField<int>&
FileCell::edge() const {
  return edge_;
}
inline ::google::protobuf::RepeatedField<int>*
FileCell::mutable_edge() {
  return &edge_;
}

// -------------------------------------------------------------------

// FileSector

// repeated .FileCell cell = 1;
inline int FileSector::cell_size() const {
  return cell_.size();
}
inline void FileSector::clear_cell() {
  cell_.Clear();
}
inline const ::FileCell& FileSector::cell(int index) const {
  return cell_.Get(index);
}
inline ::FileCell* FileSector::mutable_cell(int index) {
  return cell_.Mutable(index);
}
inline ::FileCell* FileSector::add_cell() {
  return cell_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::FileCell >&
FileSector::cell() const {
  return cell_;
}
inline ::google::protobuf::RepeatedPtrField< ::FileCell >*
FileSector::mutable_cell() {
  return &cell_;
}

// -------------------------------------------------------------------

// FileCog

// required float cog_x = 1;
inline bool FileCog::has_cog_x() const {
  return _has_bit(0);
}
inline void FileCog::clear_cog_x() {
  cog_x_ = 0;
  _clear_bit(0);
}
inline float FileCog::cog_x() const {
  return cog_x_;
}
inline void FileCog::set_cog_x(float value) {
  _set_bit(0);
  cog_x_ = value;
}

// required float cog_y = 2;
inline bool FileCog::has_cog_y() const {
  return _has_bit(1);
}
inline void FileCog::clear_cog_y() {
  cog_y_ = 0;
  _clear_bit(1);
}
inline float FileCog::cog_y() const {
  return cog_y_;
}
inline void FileCog::set_cog_y(float value) {
  _set_bit(1);
  cog_y_ = value;
}

// -------------------------------------------------------------------

// FileSign

// required float sign_x = 1;
inline bool FileSign::has_sign_x() const {
  return _has_bit(0);
}
inline void FileSign::clear_sign_x() {
  sign_x_ = 0;
  _clear_bit(0);
}
inline float FileSign::sign_x() const {
  return sign_x_;
}
inline void FileSign::set_sign_x(float value) {
  _set_bit(0);
  sign_x_ = value;
}

// required float sign_y = 2;
inline bool FileSign::has_sign_y() const {
  return _has_bit(1);
}
inline void FileSign::clear_sign_y() {
  sign_y_ = 0;
  _clear_bit(1);
}
inline float FileSign::sign_y() const {
  return sign_y_;
}
inline void FileSign::set_sign_y(float value) {
  _set_bit(1);
  sign_y_ = value;
}

// required string text = 3;
inline bool FileSign::has_text() const {
  return _has_bit(2);
}
inline void FileSign::clear_text() {
  if (text_ != &_default_text_) {
    text_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& FileSign::text() const {
  return *text_;
}
inline void FileSign::set_text(const ::std::string& value) {
  _set_bit(2);
  if (text_ == &_default_text_) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void FileSign::set_text(const char* value) {
  _set_bit(2);
  if (text_ == &_default_text_) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void FileSign::set_text(const char* value, size_t size) {
  _set_bit(2);
  if (text_ == &_default_text_) {
    text_ = new ::std::string;
  }
  text_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FileSign::mutable_text() {
  _set_bit(2);
  if (text_ == &_default_text_) {
    text_ = new ::std::string;
  }
  return text_;
}

// -------------------------------------------------------------------

// FileWorld

// required int32 players_start_x = 1;
inline bool FileWorld::has_players_start_x() const {
  return _has_bit(0);
}
inline void FileWorld::clear_players_start_x() {
  players_start_x_ = 0;
  _clear_bit(0);
}
inline ::google::protobuf::int32 FileWorld::players_start_x() const {
  return players_start_x_;
}
inline void FileWorld::set_players_start_x(::google::protobuf::int32 value) {
  _set_bit(0);
  players_start_x_ = value;
}

// required int32 players_start_y = 2;
inline bool FileWorld::has_players_start_y() const {
  return _has_bit(1);
}
inline void FileWorld::clear_players_start_y() {
  players_start_y_ = 0;
  _clear_bit(1);
}
inline ::google::protobuf::int32 FileWorld::players_start_y() const {
  return players_start_y_;
}
inline void FileWorld::set_players_start_y(::google::protobuf::int32 value) {
  _set_bit(1);
  players_start_y_ = value;
}

// required int32 players_end_x = 3;
inline bool FileWorld::has_players_end_x() const {
  return _has_bit(2);
}
inline void FileWorld::clear_players_end_x() {
  players_end_x_ = 0;
  _clear_bit(2);
}
inline ::google::protobuf::int32 FileWorld::players_end_x() const {
  return players_end_x_;
}
inline void FileWorld::set_players_end_x(::google::protobuf::int32 value) {
  _set_bit(2);
  players_end_x_ = value;
}

// required int32 players_end_y = 4;
inline bool FileWorld::has_players_end_y() const {
  return _has_bit(3);
}
inline void FileWorld::clear_players_end_y() {
  players_end_y_ = 0;
  _clear_bit(3);
}
inline ::google::protobuf::int32 FileWorld::players_end_y() const {
  return players_end_y_;
}
inline void FileWorld::set_players_end_y(::google::protobuf::int32 value) {
  _set_bit(3);
  players_end_y_ = value;
}

// required int32 width = 5;
inline bool FileWorld::has_width() const {
  return _has_bit(4);
}
inline void FileWorld::clear_width() {
  width_ = 0;
  _clear_bit(4);
}
inline ::google::protobuf::int32 FileWorld::width() const {
  return width_;
}
inline void FileWorld::set_width(::google::protobuf::int32 value) {
  _set_bit(4);
  width_ = value;
}

// required int32 height = 6;
inline bool FileWorld::has_height() const {
  return _has_bit(5);
}
inline void FileWorld::clear_height() {
  height_ = 0;
  _clear_bit(5);
}
inline ::google::protobuf::int32 FileWorld::height() const {
  return height_;
}
inline void FileWorld::set_height(::google::protobuf::int32 value) {
  _set_bit(5);
  height_ = value;
}

// repeated .FileSector sector = 7;
inline int FileWorld::sector_size() const {
  return sector_.size();
}
inline void FileWorld::clear_sector() {
  sector_.Clear();
}
inline const ::FileSector& FileWorld::sector(int index) const {
  return sector_.Get(index);
}
inline ::FileSector* FileWorld::mutable_sector(int index) {
  return sector_.Mutable(index);
}
inline ::FileSector* FileWorld::add_sector() {
  return sector_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::FileSector >&
FileWorld::sector() const {
  return sector_;
}
inline ::google::protobuf::RepeatedPtrField< ::FileSector >*
FileWorld::mutable_sector() {
  return &sector_;
}

// repeated .FileButton button = 8;
inline int FileWorld::button_size() const {
  return button_.size();
}
inline void FileWorld::clear_button() {
  button_.Clear();
}
inline const ::FileButton& FileWorld::button(int index) const {
  return button_.Get(index);
}
inline ::FileButton* FileWorld::mutable_button(int index) {
  return button_.Mutable(index);
}
inline ::FileButton* FileWorld::add_button() {
  return button_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::FileButton >&
FileWorld::button() const {
  return button_;
}
inline ::google::protobuf::RepeatedPtrField< ::FileButton >*
FileWorld::mutable_button() {
  return &button_;
}

// repeated .FileEnemy enemy = 9;
inline int FileWorld::enemy_size() const {
  return enemy_.size();
}
inline void FileWorld::clear_enemy() {
  enemy_.Clear();
}
inline const ::FileEnemy& FileWorld::enemy(int index) const {
  return enemy_.Get(index);
}
inline ::FileEnemy* FileWorld::mutable_enemy(int index) {
  return enemy_.Mutable(index);
}
inline ::FileEnemy* FileWorld::add_enemy() {
  return enemy_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::FileEnemy >&
FileWorld::enemy() const {
  return enemy_;
}
inline ::google::protobuf::RepeatedPtrField< ::FileEnemy >*
FileWorld::mutable_enemy() {
  return &enemy_;
}

// repeated .FileDoor door = 10;
inline int FileWorld::door_size() const {
  return door_.size();
}
inline void FileWorld::clear_door() {
  door_.Clear();
}
inline const ::FileDoor& FileWorld::door(int index) const {
  return door_.Get(index);
}
inline ::FileDoor* FileWorld::mutable_door(int index) {
  return door_.Mutable(index);
}
inline ::FileDoor* FileWorld::add_door() {
  return door_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::FileDoor >&
FileWorld::door() const {
  return door_;
}
inline ::google::protobuf::RepeatedPtrField< ::FileDoor >*
FileWorld::mutable_door() {
  return &door_;
}

// repeated .FileCog cog = 11;
inline int FileWorld::cog_size() const {
  return cog_.size();
}
inline void FileWorld::clear_cog() {
  cog_.Clear();
}
inline const ::FileCog& FileWorld::cog(int index) const {
  return cog_.Get(index);
}
inline ::FileCog* FileWorld::mutable_cog(int index) {
  return cog_.Mutable(index);
}
inline ::FileCog* FileWorld::add_cog() {
  return cog_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::FileCog >&
FileWorld::cog() const {
  return cog_;
}
inline ::google::protobuf::RepeatedPtrField< ::FileCog >*
FileWorld::mutable_cog() {
  return &cog_;
}

// optional int32 unique_id = 12;
inline bool FileWorld::has_unique_id() const {
  return _has_bit(11);
}
inline void FileWorld::clear_unique_id() {
  unique_id_ = 0;
  _clear_bit(11);
}
inline ::google::protobuf::int32 FileWorld::unique_id() const {
  return unique_id_;
}
inline void FileWorld::set_unique_id(::google::protobuf::int32 value) {
  _set_bit(11);
  unique_id_ = value;
}

// repeated .FileSign sign = 13;
inline int FileWorld::sign_size() const {
  return sign_.size();
}
inline void FileWorld::clear_sign() {
  sign_.Clear();
}
inline const ::FileSign& FileWorld::sign(int index) const {
  return sign_.Get(index);
}
inline ::FileSign* FileWorld::mutable_sign(int index) {
  return sign_.Mutable(index);
}
inline ::FileSign* FileWorld::add_sign() {
  return sign_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::FileSign >&
FileWorld::sign() const {
  return sign_;
}
inline ::google::protobuf::RepeatedPtrField< ::FileSign >*
FileWorld::mutable_sign() {
  return &sign_;
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::FileEnemy_EnemyType>() {
  return ::FileEnemy_EnemyType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::FileButton_ButtonBehavior>() {
  return ::FileButton_ButtonBehavior_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::FileDoor_DoorState>() {
  return ::FileDoor_DoorState_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::FileDoor_DoorType>() {
  return ::FileDoor_DoorType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::FileCell_CellType>() {
  return ::FileCell_CellType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::FileCell_EdgeType>() {
  return ::FileCell_EdgeType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< FileColor>() {
  return FileColor_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_world_2eproto__INCLUDED
